/*
OpenAPI UniBee

UniBee Api Server

API version: daily,buildtime:202508041414
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package unibee

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
)


// SubscriptionImportService SubscriptionImport service
type SubscriptionImportService service

type SubscriptionImportSubscriptionActiveSubscriptionImportGetRequest struct {
	ctx context.Context
	ApiService *SubscriptionImportService
	externalSubscriptionId *string
	externalPlanId *string
	quantity *int64
	countryCode *string
	gateway *string
	currentPeriodStart *string
	currentPeriodEnd *string
	billingCycleAnchor *string
	createTime *string
	email *string
	externalUserId *string
	vatNumber *string
	taxPercentage *int64
	firstPaidTime *string
	features *string
	expectedTotalAmount *int64
}

// Required, The external id of subscription
func (r SubscriptionImportSubscriptionActiveSubscriptionImportGetRequest) ExternalSubscriptionId(externalSubscriptionId string) SubscriptionImportSubscriptionActiveSubscriptionImportGetRequest {
	r.externalSubscriptionId = &externalSubscriptionId
	return r
}

// The external id of plan, plan should created at UniBee at first
func (r SubscriptionImportSubscriptionActiveSubscriptionImportGetRequest) ExternalPlanId(externalPlanId string) SubscriptionImportSubscriptionActiveSubscriptionImportGetRequest {
	r.externalPlanId = &externalPlanId
	return r
}

// the quantity of plan, default 1 if not provided 
func (r SubscriptionImportSubscriptionActiveSubscriptionImportGetRequest) Quantity(quantity int64) SubscriptionImportSubscriptionActiveSubscriptionImportGetRequest {
	r.quantity = &quantity
	return r
}

// Required. Specifies the ISO 3166-1 alpha-2 country code for the subscription (e.g., EE, RU). This code determines the applicable tax rules for the subscription.
func (r SubscriptionImportSubscriptionActiveSubscriptionImportGetRequest) CountryCode(countryCode string) SubscriptionImportSubscriptionActiveSubscriptionImportGetRequest {
	r.countryCode = &countryCode
	return r
}

// Required, should one of stripe|paypal|wire_transfer|changelly 
func (r SubscriptionImportSubscriptionActiveSubscriptionImportGetRequest) Gateway(gateway string) SubscriptionImportSubscriptionActiveSubscriptionImportGetRequest {
	r.gateway = &gateway
	return r
}

// Required, UTC time, the current period start time of subscription, format &#39;2006-01-02 15:04:05&#39;
func (r SubscriptionImportSubscriptionActiveSubscriptionImportGetRequest) CurrentPeriodStart(currentPeriodStart string) SubscriptionImportSubscriptionActiveSubscriptionImportGetRequest {
	r.currentPeriodStart = &currentPeriodStart
	return r
}

// Required, UTC time, the current period end time of subscription, format &#39;2006-01-02 15:04:05&#39;
func (r SubscriptionImportSubscriptionActiveSubscriptionImportGetRequest) CurrentPeriodEnd(currentPeriodEnd string) SubscriptionImportSubscriptionActiveSubscriptionImportGetRequest {
	r.currentPeriodEnd = &currentPeriodEnd
	return r
}

// Required, UTC time, The reference point that aligns future billing cycle dates. It sets the day of week for week intervals, the day of month for month and year intervals, and the month of year for year intervals, format &#39;2006-01-02 15:04:05&#39;
func (r SubscriptionImportSubscriptionActiveSubscriptionImportGetRequest) BillingCycleAnchor(billingCycleAnchor string) SubscriptionImportSubscriptionActiveSubscriptionImportGetRequest {
	r.billingCycleAnchor = &billingCycleAnchor
	return r
}

// Required, UTC time, the creation time of subscription, format &#39;2006-01-02 15:04:05&#39;
func (r SubscriptionImportSubscriptionActiveSubscriptionImportGetRequest) CreateTime(createTime string) SubscriptionImportSubscriptionActiveSubscriptionImportGetRequest {
	r.createTime = &createTime
	return r
}

// The email of user, one of Email or ExternalUserId is required
func (r SubscriptionImportSubscriptionActiveSubscriptionImportGetRequest) Email(email string) SubscriptionImportSubscriptionActiveSubscriptionImportGetRequest {
	r.email = &email
	return r
}

// The external id of user, one of Email or ExternalUserId is required 
func (r SubscriptionImportSubscriptionActiveSubscriptionImportGetRequest) ExternalUserId(externalUserId string) SubscriptionImportSubscriptionActiveSubscriptionImportGetRequest {
	r.externalUserId = &externalUserId
	return r
}

// The Vat Number of user
func (r SubscriptionImportSubscriptionActiveSubscriptionImportGetRequest) VatNumber(vatNumber string) SubscriptionImportSubscriptionActiveSubscriptionImportGetRequest {
	r.vatNumber = &vatNumber
	return r
}

// The TaxPercentage of user, valid when system vat gateway enabled, ï¼Œ1000 &#x3D; 10%
func (r SubscriptionImportSubscriptionActiveSubscriptionImportGetRequest) TaxPercentage(taxPercentage int64) SubscriptionImportSubscriptionActiveSubscriptionImportGetRequest {
	r.taxPercentage = &taxPercentage
	return r
}

// UTC time, the first payment success time of subscription, format &#39;2006-01-02 15:04:05&#39;
func (r SubscriptionImportSubscriptionActiveSubscriptionImportGetRequest) FirstPaidTime(firstPaidTime string) SubscriptionImportSubscriptionActiveSubscriptionImportGetRequest {
	r.firstPaidTime = &firstPaidTime
	return r
}

// In json format, additional features data of subscription, will join user&#39;s metric data in user api if provided&#39;
func (r SubscriptionImportSubscriptionActiveSubscriptionImportGetRequest) Features(features string) SubscriptionImportSubscriptionActiveSubscriptionImportGetRequest {
	r.features = &features
	return r
}

// Optional. Unit: cents. If greater than 0, the system will verify the calculated total amount against this value
func (r SubscriptionImportSubscriptionActiveSubscriptionImportGetRequest) ExpectedTotalAmount(expectedTotalAmount int64) SubscriptionImportSubscriptionActiveSubscriptionImportGetRequest {
	r.expectedTotalAmount = &expectedTotalAmount
	return r
}

func (r SubscriptionImportSubscriptionActiveSubscriptionImportGetRequest) Execute() (*MerchantSubscriptionActiveSubscriptionImportGet200Response, *http.Response, error) {
	return r.ApiService.SubscriptionActiveSubscriptionImportGetExecute(r)
}

/*
SubscriptionActiveSubscriptionImportGet Active Subscription Import(Allows repetition imports)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SubscriptionImportSubscriptionActiveSubscriptionImportGetRequest
*/
func (a *SubscriptionImportService) SubscriptionActiveSubscriptionImportGet(ctx context.Context) SubscriptionImportSubscriptionActiveSubscriptionImportGetRequest {
	return SubscriptionImportSubscriptionActiveSubscriptionImportGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MerchantSubscriptionActiveSubscriptionImportGet200Response
func (a *SubscriptionImportService) SubscriptionActiveSubscriptionImportGetExecute(r SubscriptionImportSubscriptionActiveSubscriptionImportGetRequest) (*MerchantSubscriptionActiveSubscriptionImportGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MerchantSubscriptionActiveSubscriptionImportGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubscriptionImportService.SubscriptionActiveSubscriptionImportGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/merchant/subscription/active_subscription_import"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.externalSubscriptionId == nil {
		return localVarReturnValue, nil, reportError("externalSubscriptionId is required and must be specified")
	}
	if r.externalPlanId == nil {
		return localVarReturnValue, nil, reportError("externalPlanId is required and must be specified")
	}
	if r.quantity == nil {
		return localVarReturnValue, nil, reportError("quantity is required and must be specified")
	}
	if r.countryCode == nil {
		return localVarReturnValue, nil, reportError("countryCode is required and must be specified")
	}
	if r.gateway == nil {
		return localVarReturnValue, nil, reportError("gateway is required and must be specified")
	}
	if r.currentPeriodStart == nil {
		return localVarReturnValue, nil, reportError("currentPeriodStart is required and must be specified")
	}
	if r.currentPeriodEnd == nil {
		return localVarReturnValue, nil, reportError("currentPeriodEnd is required and must be specified")
	}
	if r.billingCycleAnchor == nil {
		return localVarReturnValue, nil, reportError("billingCycleAnchor is required and must be specified")
	}
	if r.createTime == nil {
		return localVarReturnValue, nil, reportError("createTime is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "ExternalSubscriptionId", r.externalSubscriptionId, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "ExternalPlanId", r.externalPlanId, "")
	if r.email != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Email", r.email, "")
	}
	if r.externalUserId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ExternalUserId", r.externalUserId, "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "Quantity", r.quantity, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "CountryCode", r.countryCode, "")
	if r.vatNumber != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "VatNumber", r.vatNumber, "")
	}
	if r.taxPercentage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "TaxPercentage", r.taxPercentage, "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "Gateway", r.gateway, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "CurrentPeriodStart", r.currentPeriodStart, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "CurrentPeriodEnd", r.currentPeriodEnd, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "BillingCycleAnchor", r.billingCycleAnchor, "")
	if r.firstPaidTime != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "FirstPaidTime", r.firstPaidTime, "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "CreateTime", r.createTime, "")
	if r.features != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Features", r.features, "")
	}
	if r.expectedTotalAmount != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ExpectedTotalAmount", r.expectedTotalAmount, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SubscriptionImportSubscriptionHistorySubscriptionImportGetRequest struct {
	ctx context.Context
	ApiService *SubscriptionImportService
	externalSubscriptionId *string
	externalPlanId *string
	quantity *int64
	countryCode *string
	gateway *string
	currentPeriodStart *string
	currentPeriodEnd *string
	totalAmount *int64
	email *string
	externalUserId *string
	taxPercentage *int64
}

// Required, The external id of subscription
func (r SubscriptionImportSubscriptionHistorySubscriptionImportGetRequest) ExternalSubscriptionId(externalSubscriptionId string) SubscriptionImportSubscriptionHistorySubscriptionImportGetRequest {
	r.externalSubscriptionId = &externalSubscriptionId
	return r
}

// The external id of plan, plan should created at first
func (r SubscriptionImportSubscriptionHistorySubscriptionImportGetRequest) ExternalPlanId(externalPlanId string) SubscriptionImportSubscriptionHistorySubscriptionImportGetRequest {
	r.externalPlanId = &externalPlanId
	return r
}

// the quantity of plan, default 1 if not provided 
func (r SubscriptionImportSubscriptionHistorySubscriptionImportGetRequest) Quantity(quantity int64) SubscriptionImportSubscriptionHistorySubscriptionImportGetRequest {
	r.quantity = &quantity
	return r
}

// Required. Specifies the ISO 3166-1 alpha-2 country code for the subscription (e.g., EE, RU). This code determines the applicable tax rules for the subscription.
func (r SubscriptionImportSubscriptionHistorySubscriptionImportGetRequest) CountryCode(countryCode string) SubscriptionImportSubscriptionHistorySubscriptionImportGetRequest {
	r.countryCode = &countryCode
	return r
}

// Required, should one of stripe|paypal|wire_transfer|changelly 
func (r SubscriptionImportSubscriptionHistorySubscriptionImportGetRequest) Gateway(gateway string) SubscriptionImportSubscriptionHistorySubscriptionImportGetRequest {
	r.gateway = &gateway
	return r
}

// Required, UTC time, the current period start time of subscription, format &#39;2006-01-02 15:04:05&#39;
func (r SubscriptionImportSubscriptionHistorySubscriptionImportGetRequest) CurrentPeriodStart(currentPeriodStart string) SubscriptionImportSubscriptionHistorySubscriptionImportGetRequest {
	r.currentPeriodStart = &currentPeriodStart
	return r
}

// Required, UTC time, the current period end time of subscription, format &#39;2006-01-02 15:04:05&#39;
func (r SubscriptionImportSubscriptionHistorySubscriptionImportGetRequest) CurrentPeriodEnd(currentPeriodEnd string) SubscriptionImportSubscriptionHistorySubscriptionImportGetRequest {
	r.currentPeriodEnd = &currentPeriodEnd
	return r
}

// Required. Unit: cents.
func (r SubscriptionImportSubscriptionHistorySubscriptionImportGetRequest) TotalAmount(totalAmount int64) SubscriptionImportSubscriptionHistorySubscriptionImportGetRequest {
	r.totalAmount = &totalAmount
	return r
}

// The email of user, one of Email or ExternalUserId is required
func (r SubscriptionImportSubscriptionHistorySubscriptionImportGetRequest) Email(email string) SubscriptionImportSubscriptionHistorySubscriptionImportGetRequest {
	r.email = &email
	return r
}

// The external id of user, one of Email or ExternalUserId is required 
func (r SubscriptionImportSubscriptionHistorySubscriptionImportGetRequest) ExternalUserId(externalUserId string) SubscriptionImportSubscriptionHistorySubscriptionImportGetRequest {
	r.externalUserId = &externalUserId
	return r
}

// The TaxPercentage of subscription, valid when system vat gateway enabled, 1000 &#x3D; 10%
func (r SubscriptionImportSubscriptionHistorySubscriptionImportGetRequest) TaxPercentage(taxPercentage int64) SubscriptionImportSubscriptionHistorySubscriptionImportGetRequest {
	r.taxPercentage = &taxPercentage
	return r
}

func (r SubscriptionImportSubscriptionHistorySubscriptionImportGetRequest) Execute() (*MerchantSubscriptionActiveSubscriptionImportGet200Response, *http.Response, error) {
	return r.ApiService.SubscriptionHistorySubscriptionImportGetExecute(r)
}

/*
SubscriptionHistorySubscriptionImportGet History Subscription Import(Allows repetition imports)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SubscriptionImportSubscriptionHistorySubscriptionImportGetRequest
*/
func (a *SubscriptionImportService) SubscriptionHistorySubscriptionImportGet(ctx context.Context) SubscriptionImportSubscriptionHistorySubscriptionImportGetRequest {
	return SubscriptionImportSubscriptionHistorySubscriptionImportGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MerchantSubscriptionActiveSubscriptionImportGet200Response
func (a *SubscriptionImportService) SubscriptionHistorySubscriptionImportGetExecute(r SubscriptionImportSubscriptionHistorySubscriptionImportGetRequest) (*MerchantSubscriptionActiveSubscriptionImportGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MerchantSubscriptionActiveSubscriptionImportGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubscriptionImportService.SubscriptionHistorySubscriptionImportGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/merchant/subscription/history_subscription_import"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.externalSubscriptionId == nil {
		return localVarReturnValue, nil, reportError("externalSubscriptionId is required and must be specified")
	}
	if r.externalPlanId == nil {
		return localVarReturnValue, nil, reportError("externalPlanId is required and must be specified")
	}
	if r.quantity == nil {
		return localVarReturnValue, nil, reportError("quantity is required and must be specified")
	}
	if r.countryCode == nil {
		return localVarReturnValue, nil, reportError("countryCode is required and must be specified")
	}
	if r.gateway == nil {
		return localVarReturnValue, nil, reportError("gateway is required and must be specified")
	}
	if r.currentPeriodStart == nil {
		return localVarReturnValue, nil, reportError("currentPeriodStart is required and must be specified")
	}
	if r.currentPeriodEnd == nil {
		return localVarReturnValue, nil, reportError("currentPeriodEnd is required and must be specified")
	}
	if r.totalAmount == nil {
		return localVarReturnValue, nil, reportError("totalAmount is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "ExternalSubscriptionId", r.externalSubscriptionId, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "ExternalPlanId", r.externalPlanId, "")
	if r.email != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "Email", r.email, "")
	}
	if r.externalUserId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "ExternalUserId", r.externalUserId, "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "Quantity", r.quantity, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "CountryCode", r.countryCode, "")
	if r.taxPercentage != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "TaxPercentage", r.taxPercentage, "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "Gateway", r.gateway, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "CurrentPeriodStart", r.currentPeriodStart, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "CurrentPeriodEnd", r.currentPeriodEnd, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "TotalAmount", r.totalAmount, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

/*
OpenAPI UniBee

This is UniBee Api Server

API version: buildtime:202408060614 
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package unibee

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"reflect"
)


// PaymentService Payment service
type PaymentService service

type PaymentPaymentCancelPostRequest struct {
	ctx context.Context
	ApiService *PaymentService
	unibeeApiMerchantPaymentCancelReq *UnibeeApiMerchantPaymentCancelReq
}

func (r PaymentPaymentCancelPostRequest) UnibeeApiMerchantPaymentCancelReq(unibeeApiMerchantPaymentCancelReq UnibeeApiMerchantPaymentCancelReq) PaymentPaymentCancelPostRequest {
	r.unibeeApiMerchantPaymentCancelReq = &unibeeApiMerchantPaymentCancelReq
	return r
}

func (r PaymentPaymentCancelPostRequest) Execute() (*MerchantAuthSsoLoginOTPPost200Response, *http.Response, error) {
	return r.ApiService.PaymentCancelPostExecute(r)
}

/*
PaymentCancelPost CancelPayment

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return PaymentPaymentCancelPostRequest
*/
func (a *PaymentService) PaymentCancelPost(ctx context.Context) PaymentPaymentCancelPostRequest {
	return PaymentPaymentCancelPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MerchantAuthSsoLoginOTPPost200Response
func (a *PaymentService) PaymentCancelPostExecute(r PaymentPaymentCancelPostRequest) (*MerchantAuthSsoLoginOTPPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MerchantAuthSsoLoginOTPPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PaymentService.PaymentCancelPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/merchant/payment/cancel"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.unibeeApiMerchantPaymentCancelReq == nil {
		return localVarReturnValue, nil, reportError("unibeeApiMerchantPaymentCancelReq is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.unibeeApiMerchantPaymentCancelReq
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type PaymentPaymentCapturePostRequest struct {
	ctx context.Context
	ApiService *PaymentService
	unibeeApiMerchantPaymentCaptureReq *UnibeeApiMerchantPaymentCaptureReq
}

func (r PaymentPaymentCapturePostRequest) UnibeeApiMerchantPaymentCaptureReq(unibeeApiMerchantPaymentCaptureReq UnibeeApiMerchantPaymentCaptureReq) PaymentPaymentCapturePostRequest {
	r.unibeeApiMerchantPaymentCaptureReq = &unibeeApiMerchantPaymentCaptureReq
	return r
}

func (r PaymentPaymentCapturePostRequest) Execute() (*MerchantAuthSsoLoginOTPPost200Response, *http.Response, error) {
	return r.ApiService.PaymentCapturePostExecute(r)
}

/*
PaymentCapturePost CapturePayment

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return PaymentPaymentCapturePostRequest
*/
func (a *PaymentService) PaymentCapturePost(ctx context.Context) PaymentPaymentCapturePostRequest {
	return PaymentPaymentCapturePostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MerchantAuthSsoLoginOTPPost200Response
func (a *PaymentService) PaymentCapturePostExecute(r PaymentPaymentCapturePostRequest) (*MerchantAuthSsoLoginOTPPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MerchantAuthSsoLoginOTPPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PaymentService.PaymentCapturePost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/merchant/payment/capture"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.unibeeApiMerchantPaymentCaptureReq == nil {
		return localVarReturnValue, nil, reportError("unibeeApiMerchantPaymentCaptureReq is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.unibeeApiMerchantPaymentCaptureReq
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type PaymentPaymentDetailGetRequest struct {
	ctx context.Context
	ApiService *PaymentService
	paymentId *string
}

// The unique id of payment
func (r PaymentPaymentDetailGetRequest) PaymentId(paymentId string) PaymentPaymentDetailGetRequest {
	r.paymentId = &paymentId
	return r
}

func (r PaymentPaymentDetailGetRequest) Execute() (*MerchantPaymentDetailGet200Response, *http.Response, error) {
	return r.ApiService.PaymentDetailGetExecute(r)
}

/*
PaymentDetailGet PaymentDetail

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return PaymentPaymentDetailGetRequest
*/
func (a *PaymentService) PaymentDetailGet(ctx context.Context) PaymentPaymentDetailGetRequest {
	return PaymentPaymentDetailGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MerchantPaymentDetailGet200Response
func (a *PaymentService) PaymentDetailGetExecute(r PaymentPaymentDetailGetRequest) (*MerchantPaymentDetailGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MerchantPaymentDetailGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PaymentService.PaymentDetailGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/merchant/payment/detail"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.paymentId == nil {
		return localVarReturnValue, nil, reportError("paymentId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "paymentId", r.paymentId, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type PaymentPaymentItemListGetRequest struct {
	ctx context.Context
	ApiService *PaymentService
	userId *int64
	sortField *string
	sortType *string
	page *int32
	count *int32
}

// Filter UserId, Default All
func (r PaymentPaymentItemListGetRequest) UserId(userId int64) PaymentPaymentItemListGetRequest {
	r.userId = &userId
	return r
}

// Sort，invoice_id|gmt_create|gmt_modify|period_end|total_amount，Default gmt_modify
func (r PaymentPaymentItemListGetRequest) SortField(sortField string) PaymentPaymentItemListGetRequest {
	r.sortField = &sortField
	return r
}

// Sort Type，asc|desc，Default desc
func (r PaymentPaymentItemListGetRequest) SortType(sortType string) PaymentPaymentItemListGetRequest {
	r.sortType = &sortType
	return r
}

// Page,Start 0
func (r PaymentPaymentItemListGetRequest) Page(page int32) PaymentPaymentItemListGetRequest {
	r.page = &page
	return r
}

// Count Of Page
func (r PaymentPaymentItemListGetRequest) Count(count int32) PaymentPaymentItemListGetRequest {
	r.count = &count
	return r
}

func (r PaymentPaymentItemListGetRequest) Execute() (*MerchantPaymentItemListGet200Response, *http.Response, error) {
	return r.ApiService.PaymentItemListGetExecute(r)
}

/*
PaymentItemListGet OneTimePaymentItemList

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return PaymentPaymentItemListGetRequest
*/
func (a *PaymentService) PaymentItemListGet(ctx context.Context) PaymentPaymentItemListGetRequest {
	return PaymentPaymentItemListGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MerchantPaymentItemListGet200Response
func (a *PaymentService) PaymentItemListGetExecute(r PaymentPaymentItemListGetRequest) (*MerchantPaymentItemListGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MerchantPaymentItemListGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PaymentService.PaymentItemListGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/merchant/payment/item/list"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.userId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "userId", r.userId, "")
	}
	if r.sortField != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sortField", r.sortField, "")
	}
	if r.sortType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sortType", r.sortType, "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	if r.count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "count", r.count, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type PaymentPaymentListGetRequest struct {
	ctx context.Context
	ApiService *PaymentService
	gatewayId *int64
	userId *int64
	email *string
	status *int32
	currency *string
	countryCode *string
	sortField *string
	sortType *string
	page *int32
	count *int32
}

// The filter unique id of gateway
func (r PaymentPaymentListGetRequest) GatewayId(gatewayId int64) PaymentPaymentListGetRequest {
	r.gatewayId = &gatewayId
	return r
}

// The filter userid of payment
func (r PaymentPaymentListGetRequest) UserId(userId int64) PaymentPaymentListGetRequest {
	r.userId = &userId
	return r
}

// The filter email of payment
func (r PaymentPaymentListGetRequest) Email(email string) PaymentPaymentListGetRequest {
	r.email = &email
	return r
}

// The filter status of payment, 10-Created|20-Success|30-Failed|40-Cancelled
func (r PaymentPaymentListGetRequest) Status(status int32) PaymentPaymentListGetRequest {
	r.status = &status
	return r
}

// The filter currency of payment
func (r PaymentPaymentListGetRequest) Currency(currency string) PaymentPaymentListGetRequest {
	r.currency = &currency
	return r
}

// The filter country code of payment
func (r PaymentPaymentListGetRequest) CountryCode(countryCode string) PaymentPaymentListGetRequest {
	r.countryCode = &countryCode
	return r
}

// Sort Field，user_id|create_time|status
func (r PaymentPaymentListGetRequest) SortField(sortField string) PaymentPaymentListGetRequest {
	r.sortField = &sortField
	return r
}

// Sort Type，asc|desc
func (r PaymentPaymentListGetRequest) SortType(sortType string) PaymentPaymentListGetRequest {
	r.sortType = &sortType
	return r
}

// Page, Start With 0
func (r PaymentPaymentListGetRequest) Page(page int32) PaymentPaymentListGetRequest {
	r.page = &page
	return r
}

// Count Of Page
func (r PaymentPaymentListGetRequest) Count(count int32) PaymentPaymentListGetRequest {
	r.count = &count
	return r
}

func (r PaymentPaymentListGetRequest) Execute() (*MerchantPaymentListGet200Response, *http.Response, error) {
	return r.ApiService.PaymentListGetExecute(r)
}

/*
PaymentListGet PaymentList

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return PaymentPaymentListGetRequest
*/
func (a *PaymentService) PaymentListGet(ctx context.Context) PaymentPaymentListGetRequest {
	return PaymentPaymentListGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MerchantPaymentListGet200Response
func (a *PaymentService) PaymentListGetExecute(r PaymentPaymentListGetRequest) (*MerchantPaymentListGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MerchantPaymentListGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PaymentService.PaymentListGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/merchant/payment/list"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.gatewayId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "gatewayId", r.gatewayId, "")
	}
	if r.userId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "userId", r.userId, "")
	}
	if r.email != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "email", r.email, "")
	}
	if r.status != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "status", r.status, "")
	}
	if r.currency != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "currency", r.currency, "")
	}
	if r.countryCode != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "countryCode", r.countryCode, "")
	}
	if r.sortField != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sortField", r.sortField, "")
	}
	if r.sortType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sortType", r.sortType, "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	if r.count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "count", r.count, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type PaymentPaymentMethodDeletePostRequest struct {
	ctx context.Context
	ApiService *PaymentService
	unibeeApiMerchantPaymentMethodDeleteReq *UnibeeApiMerchantPaymentMethodDeleteReq
}

func (r PaymentPaymentMethodDeletePostRequest) UnibeeApiMerchantPaymentMethodDeleteReq(unibeeApiMerchantPaymentMethodDeleteReq UnibeeApiMerchantPaymentMethodDeleteReq) PaymentPaymentMethodDeletePostRequest {
	r.unibeeApiMerchantPaymentMethodDeleteReq = &unibeeApiMerchantPaymentMethodDeleteReq
	return r
}

func (r PaymentPaymentMethodDeletePostRequest) Execute() (*MerchantAuthSsoLoginOTPPost200Response, *http.Response, error) {
	return r.ApiService.PaymentMethodDeletePostExecute(r)
}

/*
PaymentMethodDeletePost Delete Payment Method From User

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return PaymentPaymentMethodDeletePostRequest
*/
func (a *PaymentService) PaymentMethodDeletePost(ctx context.Context) PaymentPaymentMethodDeletePostRequest {
	return PaymentPaymentMethodDeletePostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MerchantAuthSsoLoginOTPPost200Response
func (a *PaymentService) PaymentMethodDeletePostExecute(r PaymentPaymentMethodDeletePostRequest) (*MerchantAuthSsoLoginOTPPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MerchantAuthSsoLoginOTPPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PaymentService.PaymentMethodDeletePost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/merchant/payment/method_delete"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.unibeeApiMerchantPaymentMethodDeleteReq == nil {
		return localVarReturnValue, nil, reportError("unibeeApiMerchantPaymentMethodDeleteReq is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.unibeeApiMerchantPaymentMethodDeleteReq
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type PaymentPaymentMethodGetGetRequest struct {
	ctx context.Context
	ApiService *PaymentService
	gatewayId *int64
	userId *int64
	paymentMethodId *string
}

// The unique id of gateway
func (r PaymentPaymentMethodGetGetRequest) GatewayId(gatewayId int64) PaymentPaymentMethodGetGetRequest {
	r.gatewayId = &gatewayId
	return r
}

// The customer&#39;s unique id
func (r PaymentPaymentMethodGetGetRequest) UserId(userId int64) PaymentPaymentMethodGetGetRequest {
	r.userId = &userId
	return r
}

// The unique id of payment method
func (r PaymentPaymentMethodGetGetRequest) PaymentMethodId(paymentMethodId string) PaymentPaymentMethodGetGetRequest {
	r.paymentMethodId = &paymentMethodId
	return r
}

func (r PaymentPaymentMethodGetGetRequest) Execute() (*MerchantPaymentMethodGetGet200Response, *http.Response, error) {
	return r.ApiService.PaymentMethodGetGetExecute(r)
}

/*
PaymentMethodGetGet PaymentMethod

The method of payment gateway

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return PaymentPaymentMethodGetGetRequest
*/
func (a *PaymentService) PaymentMethodGetGet(ctx context.Context) PaymentPaymentMethodGetGetRequest {
	return PaymentPaymentMethodGetGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MerchantPaymentMethodGetGet200Response
func (a *PaymentService) PaymentMethodGetGetExecute(r PaymentPaymentMethodGetGetRequest) (*MerchantPaymentMethodGetGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MerchantPaymentMethodGetGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PaymentService.PaymentMethodGetGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/merchant/payment/method_get"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.gatewayId == nil {
		return localVarReturnValue, nil, reportError("gatewayId is required and must be specified")
	}
	if r.userId == nil {
		return localVarReturnValue, nil, reportError("userId is required and must be specified")
	}
	if r.paymentMethodId == nil {
		return localVarReturnValue, nil, reportError("paymentMethodId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "gatewayId", r.gatewayId, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "userId", r.userId, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "paymentMethodId", r.paymentMethodId, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type PaymentPaymentMethodListGetRequest struct {
	ctx context.Context
	ApiService *PaymentService
	gatewayId *int64
	userId *int64
	paymentId *string
}

// The unique id of gateway
func (r PaymentPaymentMethodListGetRequest) GatewayId(gatewayId int64) PaymentPaymentMethodListGetRequest {
	r.gatewayId = &gatewayId
	return r
}

// The id of user
func (r PaymentPaymentMethodListGetRequest) UserId(userId int64) PaymentPaymentMethodListGetRequest {
	r.userId = &userId
	return r
}

// The unique id of payment
func (r PaymentPaymentMethodListGetRequest) PaymentId(paymentId string) PaymentPaymentMethodListGetRequest {
	r.paymentId = &paymentId
	return r
}

func (r PaymentPaymentMethodListGetRequest) Execute() (*MerchantPaymentMethodListGet200Response, *http.Response, error) {
	return r.ApiService.PaymentMethodListGetExecute(r)
}

/*
PaymentMethodListGet PaymentMethodList

The method list of payment gateway

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return PaymentPaymentMethodListGetRequest
*/
func (a *PaymentService) PaymentMethodListGet(ctx context.Context) PaymentPaymentMethodListGetRequest {
	return PaymentPaymentMethodListGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MerchantPaymentMethodListGet200Response
func (a *PaymentService) PaymentMethodListGetExecute(r PaymentPaymentMethodListGetRequest) (*MerchantPaymentMethodListGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MerchantPaymentMethodListGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PaymentService.PaymentMethodListGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/merchant/payment/method_list"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.gatewayId == nil {
		return localVarReturnValue, nil, reportError("gatewayId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "gatewayId", r.gatewayId, "")
	if r.userId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "userId", r.userId, "")
	}
	if r.paymentId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "paymentId", r.paymentId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type PaymentPaymentMethodNewPostRequest struct {
	ctx context.Context
	ApiService *PaymentService
	unibeeApiMerchantPaymentMethodNewReq *UnibeeApiMerchantPaymentMethodNewReq
}

func (r PaymentPaymentMethodNewPostRequest) UnibeeApiMerchantPaymentMethodNewReq(unibeeApiMerchantPaymentMethodNewReq UnibeeApiMerchantPaymentMethodNewReq) PaymentPaymentMethodNewPostRequest {
	r.unibeeApiMerchantPaymentMethodNewReq = &unibeeApiMerchantPaymentMethodNewReq
	return r
}

func (r PaymentPaymentMethodNewPostRequest) Execute() (*MerchantPaymentMethodNewPost200Response, *http.Response, error) {
	return r.ApiService.PaymentMethodNewPostExecute(r)
}

/*
PaymentMethodNewPost Create New Payment Method And Attach To User

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return PaymentPaymentMethodNewPostRequest
*/
func (a *PaymentService) PaymentMethodNewPost(ctx context.Context) PaymentPaymentMethodNewPostRequest {
	return PaymentPaymentMethodNewPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MerchantPaymentMethodNewPost200Response
func (a *PaymentService) PaymentMethodNewPostExecute(r PaymentPaymentMethodNewPostRequest) (*MerchantPaymentMethodNewPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MerchantPaymentMethodNewPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PaymentService.PaymentMethodNewPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/merchant/payment/method_new"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.unibeeApiMerchantPaymentMethodNewReq == nil {
		return localVarReturnValue, nil, reportError("unibeeApiMerchantPaymentMethodNewReq is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.unibeeApiMerchantPaymentMethodNewReq
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type PaymentPaymentNewPostRequest struct {
	ctx context.Context
	ApiService *PaymentService
	unibeeApiMerchantPaymentNewReq *UnibeeApiMerchantPaymentNewReq
}

func (r PaymentPaymentNewPostRequest) UnibeeApiMerchantPaymentNewReq(unibeeApiMerchantPaymentNewReq UnibeeApiMerchantPaymentNewReq) PaymentPaymentNewPostRequest {
	r.unibeeApiMerchantPaymentNewReq = &unibeeApiMerchantPaymentNewReq
	return r
}

func (r PaymentPaymentNewPostRequest) Execute() (*MerchantPaymentNewPost200Response, *http.Response, error) {
	return r.ApiService.PaymentNewPostExecute(r)
}

/*
PaymentNewPost NewPayment

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return PaymentPaymentNewPostRequest
*/
func (a *PaymentService) PaymentNewPost(ctx context.Context) PaymentPaymentNewPostRequest {
	return PaymentPaymentNewPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MerchantPaymentNewPost200Response
func (a *PaymentService) PaymentNewPostExecute(r PaymentPaymentNewPostRequest) (*MerchantPaymentNewPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MerchantPaymentNewPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PaymentService.PaymentNewPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/merchant/payment/new"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.unibeeApiMerchantPaymentNewReq == nil {
		return localVarReturnValue, nil, reportError("unibeeApiMerchantPaymentNewReq is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.unibeeApiMerchantPaymentNewReq
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type PaymentPaymentRefundCancelPostRequest struct {
	ctx context.Context
	ApiService *PaymentService
	unibeeApiMerchantPaymentRefundCancelReq *UnibeeApiMerchantPaymentRefundCancelReq
}

func (r PaymentPaymentRefundCancelPostRequest) UnibeeApiMerchantPaymentRefundCancelReq(unibeeApiMerchantPaymentRefundCancelReq UnibeeApiMerchantPaymentRefundCancelReq) PaymentPaymentRefundCancelPostRequest {
	r.unibeeApiMerchantPaymentRefundCancelReq = &unibeeApiMerchantPaymentRefundCancelReq
	return r
}

func (r PaymentPaymentRefundCancelPostRequest) Execute() (*MerchantAuthSsoLoginOTPPost200Response, *http.Response, error) {
	return r.ApiService.PaymentRefundCancelPostExecute(r)
}

/*
PaymentRefundCancelPost CancelPaymentRefund

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return PaymentPaymentRefundCancelPostRequest
*/
func (a *PaymentService) PaymentRefundCancelPost(ctx context.Context) PaymentPaymentRefundCancelPostRequest {
	return PaymentPaymentRefundCancelPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MerchantAuthSsoLoginOTPPost200Response
func (a *PaymentService) PaymentRefundCancelPostExecute(r PaymentPaymentRefundCancelPostRequest) (*MerchantAuthSsoLoginOTPPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MerchantAuthSsoLoginOTPPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PaymentService.PaymentRefundCancelPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/merchant/payment/refund/cancel"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.unibeeApiMerchantPaymentRefundCancelReq == nil {
		return localVarReturnValue, nil, reportError("unibeeApiMerchantPaymentRefundCancelReq is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.unibeeApiMerchantPaymentRefundCancelReq
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type PaymentPaymentRefundDetailGetRequest struct {
	ctx context.Context
	ApiService *PaymentService
	refundId *string
}

// RefundId
func (r PaymentPaymentRefundDetailGetRequest) RefundId(refundId string) PaymentPaymentRefundDetailGetRequest {
	r.refundId = &refundId
	return r
}

func (r PaymentPaymentRefundDetailGetRequest) Execute() (*MerchantPaymentRefundDetailGet200Response, *http.Response, error) {
	return r.ApiService.PaymentRefundDetailGetExecute(r)
}

/*
PaymentRefundDetailGet PaymentRefundDetail

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return PaymentPaymentRefundDetailGetRequest
*/
func (a *PaymentService) PaymentRefundDetailGet(ctx context.Context) PaymentPaymentRefundDetailGetRequest {
	return PaymentPaymentRefundDetailGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MerchantPaymentRefundDetailGet200Response
func (a *PaymentService) PaymentRefundDetailGetExecute(r PaymentPaymentRefundDetailGetRequest) (*MerchantPaymentRefundDetailGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MerchantPaymentRefundDetailGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PaymentService.PaymentRefundDetailGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/merchant/payment/refund/detail"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.refundId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "refundId", r.refundId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type PaymentPaymentRefundListGetRequest struct {
	ctx context.Context
	ApiService *PaymentService
	paymentId *string
	status *int32
	gatewayId *int64
	userId *int64
	email *string
	currency *string
}

// PaymentId
func (r PaymentPaymentRefundListGetRequest) PaymentId(paymentId string) PaymentPaymentRefundListGetRequest {
	r.paymentId = &paymentId
	return r
}

// Status,10-create|20-success|30-Failed|40-Reverse
func (r PaymentPaymentRefundListGetRequest) Status(status int32) PaymentPaymentRefundListGetRequest {
	r.status = &status
	return r
}

// GatewayId
func (r PaymentPaymentRefundListGetRequest) GatewayId(gatewayId int64) PaymentPaymentRefundListGetRequest {
	r.gatewayId = &gatewayId
	return r
}

// UserId
func (r PaymentPaymentRefundListGetRequest) UserId(userId int64) PaymentPaymentRefundListGetRequest {
	r.userId = &userId
	return r
}

// Email
func (r PaymentPaymentRefundListGetRequest) Email(email string) PaymentPaymentRefundListGetRequest {
	r.email = &email
	return r
}

// Currency
func (r PaymentPaymentRefundListGetRequest) Currency(currency string) PaymentPaymentRefundListGetRequest {
	r.currency = &currency
	return r
}

func (r PaymentPaymentRefundListGetRequest) Execute() (*MerchantPaymentRefundListGet200Response, *http.Response, error) {
	return r.ApiService.PaymentRefundListGetExecute(r)
}

/*
PaymentRefundListGet PaymentRefundList

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return PaymentPaymentRefundListGetRequest
*/
func (a *PaymentService) PaymentRefundListGet(ctx context.Context) PaymentPaymentRefundListGetRequest {
	return PaymentPaymentRefundListGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MerchantPaymentRefundListGet200Response
func (a *PaymentService) PaymentRefundListGetExecute(r PaymentPaymentRefundListGetRequest) (*MerchantPaymentRefundListGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MerchantPaymentRefundListGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PaymentService.PaymentRefundListGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/merchant/payment/refund/list"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.paymentId == nil {
		return localVarReturnValue, nil, reportError("paymentId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "paymentId", r.paymentId, "")
	if r.status != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "status", r.status, "")
	}
	if r.gatewayId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "gatewayId", r.gatewayId, "")
	}
	if r.userId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "userId", r.userId, "")
	}
	if r.email != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "email", r.email, "")
	}
	if r.currency != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "currency", r.currency, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type PaymentPaymentRefundNewPostRequest struct {
	ctx context.Context
	ApiService *PaymentService
	unibeeApiMerchantPaymentNewPaymentRefundReq *UnibeeApiMerchantPaymentNewPaymentRefundReq
}

func (r PaymentPaymentRefundNewPostRequest) UnibeeApiMerchantPaymentNewPaymentRefundReq(unibeeApiMerchantPaymentNewPaymentRefundReq UnibeeApiMerchantPaymentNewPaymentRefundReq) PaymentPaymentRefundNewPostRequest {
	r.unibeeApiMerchantPaymentNewPaymentRefundReq = &unibeeApiMerchantPaymentNewPaymentRefundReq
	return r
}

func (r PaymentPaymentRefundNewPostRequest) Execute() (*MerchantPaymentRefundNewPost200Response, *http.Response, error) {
	return r.ApiService.PaymentRefundNewPostExecute(r)
}

/*
PaymentRefundNewPost NewPaymentRefund

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return PaymentPaymentRefundNewPostRequest
*/
func (a *PaymentService) PaymentRefundNewPost(ctx context.Context) PaymentPaymentRefundNewPostRequest {
	return PaymentPaymentRefundNewPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MerchantPaymentRefundNewPost200Response
func (a *PaymentService) PaymentRefundNewPostExecute(r PaymentPaymentRefundNewPostRequest) (*MerchantPaymentRefundNewPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MerchantPaymentRefundNewPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PaymentService.PaymentRefundNewPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/merchant/payment/refund/new"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.unibeeApiMerchantPaymentNewPaymentRefundReq == nil {
		return localVarReturnValue, nil, reportError("unibeeApiMerchantPaymentNewPaymentRefundReq is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.unibeeApiMerchantPaymentNewPaymentRefundReq
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type PaymentPaymentTimelineListGetRequest struct {
	ctx context.Context
	ApiService *PaymentService
	userId *int64
	amountStart *int32
	amountEnd *int32
	status *[]int32
	timelineTypes *[]int32
	gatewayIds *[]int64
	currency *string
	sortField *string
	sortType *string
	page *int32
	count *int32
	createTimeStart *int64
	createTimeEnd *int64
}

// Filter UserId, Default All
func (r PaymentPaymentTimelineListGetRequest) UserId(userId int64) PaymentPaymentTimelineListGetRequest {
	r.userId = &userId
	return r
}

// The filter start amount of timeline
func (r PaymentPaymentTimelineListGetRequest) AmountStart(amountStart int32) PaymentPaymentTimelineListGetRequest {
	r.amountStart = &amountStart
	return r
}

// The filter end amount of timeline
func (r PaymentPaymentTimelineListGetRequest) AmountEnd(amountEnd int32) PaymentPaymentTimelineListGetRequest {
	r.amountEnd = &amountEnd
	return r
}

// The filter status, 0-pending, 1-success, 2-failure
func (r PaymentPaymentTimelineListGetRequest) Status(status []int32) PaymentPaymentTimelineListGetRequest {
	r.status = &status
	return r
}

// The filter timelineType, 0-pay, 1-refund
func (r PaymentPaymentTimelineListGetRequest) TimelineTypes(timelineTypes []int32) PaymentPaymentTimelineListGetRequest {
	r.timelineTypes = &timelineTypes
	return r
}

// The filter ids of gateway
func (r PaymentPaymentTimelineListGetRequest) GatewayIds(gatewayIds []int64) PaymentPaymentTimelineListGetRequest {
	r.gatewayIds = &gatewayIds
	return r
}

// Currency
func (r PaymentPaymentTimelineListGetRequest) Currency(currency string) PaymentPaymentTimelineListGetRequest {
	r.currency = &currency
	return r
}

// Sort，invoice_id|gmt_create|gmt_modify|period_end|total_amount，Default gmt_modify
func (r PaymentPaymentTimelineListGetRequest) SortField(sortField string) PaymentPaymentTimelineListGetRequest {
	r.sortField = &sortField
	return r
}

// Sort Type，asc|desc，Default desc
func (r PaymentPaymentTimelineListGetRequest) SortType(sortType string) PaymentPaymentTimelineListGetRequest {
	r.sortType = &sortType
	return r
}

// Page,Start 0
func (r PaymentPaymentTimelineListGetRequest) Page(page int32) PaymentPaymentTimelineListGetRequest {
	r.page = &page
	return r
}

// Count Of Page
func (r PaymentPaymentTimelineListGetRequest) Count(count int32) PaymentPaymentTimelineListGetRequest {
	r.count = &count
	return r
}

// CreateTimeStart
func (r PaymentPaymentTimelineListGetRequest) CreateTimeStart(createTimeStart int64) PaymentPaymentTimelineListGetRequest {
	r.createTimeStart = &createTimeStart
	return r
}

// CreateTimeEnd
func (r PaymentPaymentTimelineListGetRequest) CreateTimeEnd(createTimeEnd int64) PaymentPaymentTimelineListGetRequest {
	r.createTimeEnd = &createTimeEnd
	return r
}

func (r PaymentPaymentTimelineListGetRequest) Execute() (*MerchantPaymentTimelineListGet200Response, *http.Response, error) {
	return r.ApiService.PaymentTimelineListGetExecute(r)
}

/*
PaymentTimelineListGet PaymentTimeLineList

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return PaymentPaymentTimelineListGetRequest
*/
func (a *PaymentService) PaymentTimelineListGet(ctx context.Context) PaymentPaymentTimelineListGetRequest {
	return PaymentPaymentTimelineListGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MerchantPaymentTimelineListGet200Response
func (a *PaymentService) PaymentTimelineListGetExecute(r PaymentPaymentTimelineListGetRequest) (*MerchantPaymentTimelineListGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MerchantPaymentTimelineListGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "PaymentService.PaymentTimelineListGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/merchant/payment/timeline/list"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.userId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "userId", r.userId, "")
	}
	if r.amountStart != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "amountStart", r.amountStart, "")
	}
	if r.amountEnd != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "amountEnd", r.amountEnd, "")
	}
	if r.status != nil {
		t := *r.status
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "status", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "status", t, "multi")
		}
	}
	if r.timelineTypes != nil {
		t := *r.timelineTypes
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "timelineTypes", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "timelineTypes", t, "multi")
		}
	}
	if r.gatewayIds != nil {
		t := *r.gatewayIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "gatewayIds", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "gatewayIds", t, "multi")
		}
	}
	if r.currency != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "currency", r.currency, "")
	}
	if r.sortField != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sortField", r.sortField, "")
	}
	if r.sortType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sortType", r.sortType, "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	if r.count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "count", r.count, "")
	}
	if r.createTimeStart != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "createTimeStart", r.createTimeStart, "")
	}
	if r.createTimeEnd != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "createTimeEnd", r.createTimeEnd, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

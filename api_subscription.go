/*
OpenAPI UniBee

This is UniBee Api Server

API version: buildtime:202408160545 
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package unibee

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"reflect"
)


// SubscriptionService Subscription service
type SubscriptionService service

type SubscriptionSubscriptionActiveTemporarilyPostRequest struct {
	ctx context.Context
	ApiService *SubscriptionService
	unibeeApiMerchantSubscriptionActiveTemporarilyReq *UnibeeApiMerchantSubscriptionActiveTemporarilyReq
}

func (r SubscriptionSubscriptionActiveTemporarilyPostRequest) UnibeeApiMerchantSubscriptionActiveTemporarilyReq(unibeeApiMerchantSubscriptionActiveTemporarilyReq UnibeeApiMerchantSubscriptionActiveTemporarilyReq) SubscriptionSubscriptionActiveTemporarilyPostRequest {
	r.unibeeApiMerchantSubscriptionActiveTemporarilyReq = &unibeeApiMerchantSubscriptionActiveTemporarilyReq
	return r
}

func (r SubscriptionSubscriptionActiveTemporarilyPostRequest) Execute() (*MerchantAuthSsoLoginOTPPost200Response, *http.Response, error) {
	return r.ApiService.SubscriptionActiveTemporarilyPostExecute(r)
}

/*
SubscriptionActiveTemporarilyPost SubscriptionActiveTemporarily

Subscription active temporarily, status will transmit from pending to incomplete

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SubscriptionSubscriptionActiveTemporarilyPostRequest
*/
func (a *SubscriptionService) SubscriptionActiveTemporarilyPost(ctx context.Context) SubscriptionSubscriptionActiveTemporarilyPostRequest {
	return SubscriptionSubscriptionActiveTemporarilyPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MerchantAuthSsoLoginOTPPost200Response
func (a *SubscriptionService) SubscriptionActiveTemporarilyPostExecute(r SubscriptionSubscriptionActiveTemporarilyPostRequest) (*MerchantAuthSsoLoginOTPPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MerchantAuthSsoLoginOTPPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubscriptionService.SubscriptionActiveTemporarilyPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/merchant/subscription/active_temporarily"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.unibeeApiMerchantSubscriptionActiveTemporarilyReq == nil {
		return localVarReturnValue, nil, reportError("unibeeApiMerchantSubscriptionActiveTemporarilyReq is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.unibeeApiMerchantSubscriptionActiveTemporarilyReq
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SubscriptionSubscriptionAddNewTrialStartPostRequest struct {
	ctx context.Context
	ApiService *SubscriptionService
	unibeeApiMerchantSubscriptionAddNewTrialStartReq *UnibeeApiMerchantSubscriptionAddNewTrialStartReq
}

func (r SubscriptionSubscriptionAddNewTrialStartPostRequest) UnibeeApiMerchantSubscriptionAddNewTrialStartReq(unibeeApiMerchantSubscriptionAddNewTrialStartReq UnibeeApiMerchantSubscriptionAddNewTrialStartReq) SubscriptionSubscriptionAddNewTrialStartPostRequest {
	r.unibeeApiMerchantSubscriptionAddNewTrialStartReq = &unibeeApiMerchantSubscriptionAddNewTrialStartReq
	return r
}

func (r SubscriptionSubscriptionAddNewTrialStartPostRequest) Execute() (*MerchantAuthSsoLoginOTPPost200Response, *http.Response, error) {
	return r.ApiService.SubscriptionAddNewTrialStartPostExecute(r)
}

/*
SubscriptionAddNewTrialStartPost AppendSubscriptionTrialEnd

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SubscriptionSubscriptionAddNewTrialStartPostRequest
*/
func (a *SubscriptionService) SubscriptionAddNewTrialStartPost(ctx context.Context) SubscriptionSubscriptionAddNewTrialStartPostRequest {
	return SubscriptionSubscriptionAddNewTrialStartPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MerchantAuthSsoLoginOTPPost200Response
func (a *SubscriptionService) SubscriptionAddNewTrialStartPostExecute(r SubscriptionSubscriptionAddNewTrialStartPostRequest) (*MerchantAuthSsoLoginOTPPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MerchantAuthSsoLoginOTPPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubscriptionService.SubscriptionAddNewTrialStartPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/merchant/subscription/add_new_trial_start"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.unibeeApiMerchantSubscriptionAddNewTrialStartReq == nil {
		return localVarReturnValue, nil, reportError("unibeeApiMerchantSubscriptionAddNewTrialStartReq is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.unibeeApiMerchantSubscriptionAddNewTrialStartReq
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SubscriptionSubscriptionCancelAtPeriodEndPostRequest struct {
	ctx context.Context
	ApiService *SubscriptionService
	unibeeApiMerchantSubscriptionCancelAtPeriodEndReq *UnibeeApiMerchantSubscriptionCancelAtPeriodEndReq
}

func (r SubscriptionSubscriptionCancelAtPeriodEndPostRequest) UnibeeApiMerchantSubscriptionCancelAtPeriodEndReq(unibeeApiMerchantSubscriptionCancelAtPeriodEndReq UnibeeApiMerchantSubscriptionCancelAtPeriodEndReq) SubscriptionSubscriptionCancelAtPeriodEndPostRequest {
	r.unibeeApiMerchantSubscriptionCancelAtPeriodEndReq = &unibeeApiMerchantSubscriptionCancelAtPeriodEndReq
	return r
}

func (r SubscriptionSubscriptionCancelAtPeriodEndPostRequest) Execute() (*MerchantAuthSsoLoginOTPPost200Response, *http.Response, error) {
	return r.ApiService.SubscriptionCancelAtPeriodEndPostExecute(r)
}

/*
SubscriptionCancelAtPeriodEndPost CancelSubscriptionAtPeriodEnd

Cancel subscription at period end, the subscription will not turn to 'cancelled' at once but will cancelled at period end time, no invoice will generate, the flag 'cancelAtPeriodEnd' of subscription will be enabled

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SubscriptionSubscriptionCancelAtPeriodEndPostRequest
*/
func (a *SubscriptionService) SubscriptionCancelAtPeriodEndPost(ctx context.Context) SubscriptionSubscriptionCancelAtPeriodEndPostRequest {
	return SubscriptionSubscriptionCancelAtPeriodEndPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MerchantAuthSsoLoginOTPPost200Response
func (a *SubscriptionService) SubscriptionCancelAtPeriodEndPostExecute(r SubscriptionSubscriptionCancelAtPeriodEndPostRequest) (*MerchantAuthSsoLoginOTPPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MerchantAuthSsoLoginOTPPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubscriptionService.SubscriptionCancelAtPeriodEndPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/merchant/subscription/cancel_at_period_end"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.unibeeApiMerchantSubscriptionCancelAtPeriodEndReq == nil {
		return localVarReturnValue, nil, reportError("unibeeApiMerchantSubscriptionCancelAtPeriodEndReq is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.unibeeApiMerchantSubscriptionCancelAtPeriodEndReq
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SubscriptionSubscriptionCancelLastCancelAtPeriodEndPostRequest struct {
	ctx context.Context
	ApiService *SubscriptionService
	unibeeApiMerchantSubscriptionCancelLastCancelAtPeriodEndReq *UnibeeApiMerchantSubscriptionCancelLastCancelAtPeriodEndReq
}

func (r SubscriptionSubscriptionCancelLastCancelAtPeriodEndPostRequest) UnibeeApiMerchantSubscriptionCancelLastCancelAtPeriodEndReq(unibeeApiMerchantSubscriptionCancelLastCancelAtPeriodEndReq UnibeeApiMerchantSubscriptionCancelLastCancelAtPeriodEndReq) SubscriptionSubscriptionCancelLastCancelAtPeriodEndPostRequest {
	r.unibeeApiMerchantSubscriptionCancelLastCancelAtPeriodEndReq = &unibeeApiMerchantSubscriptionCancelLastCancelAtPeriodEndReq
	return r
}

func (r SubscriptionSubscriptionCancelLastCancelAtPeriodEndPostRequest) Execute() (*MerchantAuthSsoLoginOTPPost200Response, *http.Response, error) {
	return r.ApiService.SubscriptionCancelLastCancelAtPeriodEndPostExecute(r)
}

/*
SubscriptionCancelLastCancelAtPeriodEndPost CancelLastCancelSubscriptionAtPeriodEnd

This action should be request before subscription's period end, If subscription's flag 'cancelAtPeriodEnd' is enabled, this action will resume it to disable, and subscription will continue cycle recurring seems no cancelAtPeriod action be setting

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SubscriptionSubscriptionCancelLastCancelAtPeriodEndPostRequest
*/
func (a *SubscriptionService) SubscriptionCancelLastCancelAtPeriodEndPost(ctx context.Context) SubscriptionSubscriptionCancelLastCancelAtPeriodEndPostRequest {
	return SubscriptionSubscriptionCancelLastCancelAtPeriodEndPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MerchantAuthSsoLoginOTPPost200Response
func (a *SubscriptionService) SubscriptionCancelLastCancelAtPeriodEndPostExecute(r SubscriptionSubscriptionCancelLastCancelAtPeriodEndPostRequest) (*MerchantAuthSsoLoginOTPPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MerchantAuthSsoLoginOTPPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubscriptionService.SubscriptionCancelLastCancelAtPeriodEndPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/merchant/subscription/cancel_last_cancel_at_period_end"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.unibeeApiMerchantSubscriptionCancelLastCancelAtPeriodEndReq == nil {
		return localVarReturnValue, nil, reportError("unibeeApiMerchantSubscriptionCancelLastCancelAtPeriodEndReq is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.unibeeApiMerchantSubscriptionCancelLastCancelAtPeriodEndReq
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SubscriptionSubscriptionCancelPostRequest struct {
	ctx context.Context
	ApiService *SubscriptionService
	unibeeApiMerchantSubscriptionCancelReq *UnibeeApiMerchantSubscriptionCancelReq
}

func (r SubscriptionSubscriptionCancelPostRequest) UnibeeApiMerchantSubscriptionCancelReq(unibeeApiMerchantSubscriptionCancelReq UnibeeApiMerchantSubscriptionCancelReq) SubscriptionSubscriptionCancelPostRequest {
	r.unibeeApiMerchantSubscriptionCancelReq = &unibeeApiMerchantSubscriptionCancelReq
	return r
}

func (r SubscriptionSubscriptionCancelPostRequest) Execute() (*MerchantAuthSsoLoginOTPPost200Response, *http.Response, error) {
	return r.ApiService.SubscriptionCancelPostExecute(r)
}

/*
SubscriptionCancelPost CancelSubscriptionImmediately

Cancel subscription immediately, no proration invoice will generate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SubscriptionSubscriptionCancelPostRequest
*/
func (a *SubscriptionService) SubscriptionCancelPost(ctx context.Context) SubscriptionSubscriptionCancelPostRequest {
	return SubscriptionSubscriptionCancelPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MerchantAuthSsoLoginOTPPost200Response
func (a *SubscriptionService) SubscriptionCancelPostExecute(r SubscriptionSubscriptionCancelPostRequest) (*MerchantAuthSsoLoginOTPPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MerchantAuthSsoLoginOTPPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubscriptionService.SubscriptionCancelPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/merchant/subscription/cancel"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.unibeeApiMerchantSubscriptionCancelReq == nil {
		return localVarReturnValue, nil, reportError("unibeeApiMerchantSubscriptionCancelReq is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.unibeeApiMerchantSubscriptionCancelReq
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SubscriptionSubscriptionChangeGatewayPostRequest struct {
	ctx context.Context
	ApiService *SubscriptionService
	unibeeApiMerchantSubscriptionChangeGatewayReq *UnibeeApiMerchantSubscriptionChangeGatewayReq
}

func (r SubscriptionSubscriptionChangeGatewayPostRequest) UnibeeApiMerchantSubscriptionChangeGatewayReq(unibeeApiMerchantSubscriptionChangeGatewayReq UnibeeApiMerchantSubscriptionChangeGatewayReq) SubscriptionSubscriptionChangeGatewayPostRequest {
	r.unibeeApiMerchantSubscriptionChangeGatewayReq = &unibeeApiMerchantSubscriptionChangeGatewayReq
	return r
}

func (r SubscriptionSubscriptionChangeGatewayPostRequest) Execute() (*MerchantAuthSsoLoginOTPPost200Response, *http.Response, error) {
	return r.ApiService.SubscriptionChangeGatewayPostExecute(r)
}

/*
SubscriptionChangeGatewayPost ChangeSubscriptionGateway

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SubscriptionSubscriptionChangeGatewayPostRequest
*/
func (a *SubscriptionService) SubscriptionChangeGatewayPost(ctx context.Context) SubscriptionSubscriptionChangeGatewayPostRequest {
	return SubscriptionSubscriptionChangeGatewayPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MerchantAuthSsoLoginOTPPost200Response
func (a *SubscriptionService) SubscriptionChangeGatewayPostExecute(r SubscriptionSubscriptionChangeGatewayPostRequest) (*MerchantAuthSsoLoginOTPPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MerchantAuthSsoLoginOTPPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubscriptionService.SubscriptionChangeGatewayPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/merchant/subscription/change_gateway"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.unibeeApiMerchantSubscriptionChangeGatewayReq == nil {
		return localVarReturnValue, nil, reportError("unibeeApiMerchantSubscriptionChangeGatewayReq is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.unibeeApiMerchantSubscriptionChangeGatewayReq
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SubscriptionSubscriptionConfigGetRequest struct {
	ctx context.Context
	ApiService *SubscriptionService
}

func (r SubscriptionSubscriptionConfigGetRequest) Execute() (*MerchantSubscriptionConfigGet200Response, *http.Response, error) {
	return r.ApiService.SubscriptionConfigGetExecute(r)
}

/*
SubscriptionConfigGet SubscriptionConfig

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SubscriptionSubscriptionConfigGetRequest
*/
func (a *SubscriptionService) SubscriptionConfigGet(ctx context.Context) SubscriptionSubscriptionConfigGetRequest {
	return SubscriptionSubscriptionConfigGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MerchantSubscriptionConfigGet200Response
func (a *SubscriptionService) SubscriptionConfigGetExecute(r SubscriptionSubscriptionConfigGetRequest) (*MerchantSubscriptionConfigGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MerchantSubscriptionConfigGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubscriptionService.SubscriptionConfigGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/merchant/subscription/config"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SubscriptionSubscriptionConfigUpdatePostRequest struct {
	ctx context.Context
	ApiService *SubscriptionService
	unibeeApiMerchantSubscriptionConfigUpdateReq *UnibeeApiMerchantSubscriptionConfigUpdateReq
}

func (r SubscriptionSubscriptionConfigUpdatePostRequest) UnibeeApiMerchantSubscriptionConfigUpdateReq(unibeeApiMerchantSubscriptionConfigUpdateReq UnibeeApiMerchantSubscriptionConfigUpdateReq) SubscriptionSubscriptionConfigUpdatePostRequest {
	r.unibeeApiMerchantSubscriptionConfigUpdateReq = &unibeeApiMerchantSubscriptionConfigUpdateReq
	return r
}

func (r SubscriptionSubscriptionConfigUpdatePostRequest) Execute() (*MerchantSubscriptionConfigGet200Response, *http.Response, error) {
	return r.ApiService.SubscriptionConfigUpdatePostExecute(r)
}

/*
SubscriptionConfigUpdatePost Update Merchant Subscription Config

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SubscriptionSubscriptionConfigUpdatePostRequest
*/
func (a *SubscriptionService) SubscriptionConfigUpdatePost(ctx context.Context) SubscriptionSubscriptionConfigUpdatePostRequest {
	return SubscriptionSubscriptionConfigUpdatePostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MerchantSubscriptionConfigGet200Response
func (a *SubscriptionService) SubscriptionConfigUpdatePostExecute(r SubscriptionSubscriptionConfigUpdatePostRequest) (*MerchantSubscriptionConfigGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MerchantSubscriptionConfigGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubscriptionService.SubscriptionConfigUpdatePost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/merchant/subscription/config/update"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.unibeeApiMerchantSubscriptionConfigUpdateReq == nil {
		return localVarReturnValue, nil, reportError("unibeeApiMerchantSubscriptionConfigUpdateReq is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.unibeeApiMerchantSubscriptionConfigUpdateReq
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SubscriptionSubscriptionCreatePreviewPostRequest struct {
	ctx context.Context
	ApiService *SubscriptionService
	unibeeApiMerchantSubscriptionCreatePreviewReq *UnibeeApiMerchantSubscriptionCreatePreviewReq
}

func (r SubscriptionSubscriptionCreatePreviewPostRequest) UnibeeApiMerchantSubscriptionCreatePreviewReq(unibeeApiMerchantSubscriptionCreatePreviewReq UnibeeApiMerchantSubscriptionCreatePreviewReq) SubscriptionSubscriptionCreatePreviewPostRequest {
	r.unibeeApiMerchantSubscriptionCreatePreviewReq = &unibeeApiMerchantSubscriptionCreatePreviewReq
	return r
}

func (r SubscriptionSubscriptionCreatePreviewPostRequest) Execute() (*MerchantSubscriptionCreatePreviewPost200Response, *http.Response, error) {
	return r.ApiService.SubscriptionCreatePreviewPostExecute(r)
}

/*
SubscriptionCreatePreviewPost CreateSubscriptionPreview

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SubscriptionSubscriptionCreatePreviewPostRequest
*/
func (a *SubscriptionService) SubscriptionCreatePreviewPost(ctx context.Context) SubscriptionSubscriptionCreatePreviewPostRequest {
	return SubscriptionSubscriptionCreatePreviewPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MerchantSubscriptionCreatePreviewPost200Response
func (a *SubscriptionService) SubscriptionCreatePreviewPostExecute(r SubscriptionSubscriptionCreatePreviewPostRequest) (*MerchantSubscriptionCreatePreviewPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MerchantSubscriptionCreatePreviewPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubscriptionService.SubscriptionCreatePreviewPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/merchant/subscription/create_preview"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.unibeeApiMerchantSubscriptionCreatePreviewReq == nil {
		return localVarReturnValue, nil, reportError("unibeeApiMerchantSubscriptionCreatePreviewReq is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.unibeeApiMerchantSubscriptionCreatePreviewReq
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SubscriptionSubscriptionCreateSubmitPostRequest struct {
	ctx context.Context
	ApiService *SubscriptionService
	unibeeApiMerchantSubscriptionCreateReq *UnibeeApiMerchantSubscriptionCreateReq
}

func (r SubscriptionSubscriptionCreateSubmitPostRequest) UnibeeApiMerchantSubscriptionCreateReq(unibeeApiMerchantSubscriptionCreateReq UnibeeApiMerchantSubscriptionCreateReq) SubscriptionSubscriptionCreateSubmitPostRequest {
	r.unibeeApiMerchantSubscriptionCreateReq = &unibeeApiMerchantSubscriptionCreateReq
	return r
}

func (r SubscriptionSubscriptionCreateSubmitPostRequest) Execute() (*MerchantSubscriptionCreateSubmitPost200Response, *http.Response, error) {
	return r.ApiService.SubscriptionCreateSubmitPostExecute(r)
}

/*
SubscriptionCreateSubmitPost CreateSubscription

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SubscriptionSubscriptionCreateSubmitPostRequest
*/
func (a *SubscriptionService) SubscriptionCreateSubmitPost(ctx context.Context) SubscriptionSubscriptionCreateSubmitPostRequest {
	return SubscriptionSubscriptionCreateSubmitPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MerchantSubscriptionCreateSubmitPost200Response
func (a *SubscriptionService) SubscriptionCreateSubmitPostExecute(r SubscriptionSubscriptionCreateSubmitPostRequest) (*MerchantSubscriptionCreateSubmitPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MerchantSubscriptionCreateSubmitPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubscriptionService.SubscriptionCreateSubmitPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/merchant/subscription/create_submit"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.unibeeApiMerchantSubscriptionCreateReq == nil {
		return localVarReturnValue, nil, reportError("unibeeApiMerchantSubscriptionCreateReq is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.unibeeApiMerchantSubscriptionCreateReq
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SubscriptionSubscriptionDetailGetRequest struct {
	ctx context.Context
	ApiService *SubscriptionService
	subscriptionId *string
}

// SubscriptionId
func (r SubscriptionSubscriptionDetailGetRequest) SubscriptionId(subscriptionId string) SubscriptionSubscriptionDetailGetRequest {
	r.subscriptionId = &subscriptionId
	return r
}

func (r SubscriptionSubscriptionDetailGetRequest) Execute() (*MerchantSubscriptionDetailGet200Response, *http.Response, error) {
	return r.ApiService.SubscriptionDetailGetExecute(r)
}

/*
SubscriptionDetailGet SubscriptionDetail

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SubscriptionSubscriptionDetailGetRequest
*/
func (a *SubscriptionService) SubscriptionDetailGet(ctx context.Context) SubscriptionSubscriptionDetailGetRequest {
	return SubscriptionSubscriptionDetailGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MerchantSubscriptionDetailGet200Response
func (a *SubscriptionService) SubscriptionDetailGetExecute(r SubscriptionSubscriptionDetailGetRequest) (*MerchantSubscriptionDetailGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MerchantSubscriptionDetailGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubscriptionService.SubscriptionDetailGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/merchant/subscription/detail"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.subscriptionId == nil {
		return localVarReturnValue, nil, reportError("subscriptionId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "subscriptionId", r.subscriptionId, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SubscriptionSubscriptionDetailPostRequest struct {
	ctx context.Context
	ApiService *SubscriptionService
	unibeeApiMerchantSubscriptionDetailReq *UnibeeApiMerchantSubscriptionDetailReq
}

func (r SubscriptionSubscriptionDetailPostRequest) UnibeeApiMerchantSubscriptionDetailReq(unibeeApiMerchantSubscriptionDetailReq UnibeeApiMerchantSubscriptionDetailReq) SubscriptionSubscriptionDetailPostRequest {
	r.unibeeApiMerchantSubscriptionDetailReq = &unibeeApiMerchantSubscriptionDetailReq
	return r
}

func (r SubscriptionSubscriptionDetailPostRequest) Execute() (*MerchantSubscriptionDetailGet200Response, *http.Response, error) {
	return r.ApiService.SubscriptionDetailPostExecute(r)
}

/*
SubscriptionDetailPost SubscriptionDetail

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SubscriptionSubscriptionDetailPostRequest
*/
func (a *SubscriptionService) SubscriptionDetailPost(ctx context.Context) SubscriptionSubscriptionDetailPostRequest {
	return SubscriptionSubscriptionDetailPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MerchantSubscriptionDetailGet200Response
func (a *SubscriptionService) SubscriptionDetailPostExecute(r SubscriptionSubscriptionDetailPostRequest) (*MerchantSubscriptionDetailGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MerchantSubscriptionDetailGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubscriptionService.SubscriptionDetailPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/merchant/subscription/detail"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.unibeeApiMerchantSubscriptionDetailReq == nil {
		return localVarReturnValue, nil, reportError("unibeeApiMerchantSubscriptionDetailReq is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.unibeeApiMerchantSubscriptionDetailReq
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SubscriptionSubscriptionListGetRequest struct {
	ctx context.Context
	ApiService *SubscriptionService
	userId *int64
	status *[]int32
	currency *string
	planIds *[]int64
	productIds *[]int64
	amountStart *int32
	amountEnd *int32
	sortField *string
	sortType *string
	page *int32
	count *int32
	createTimeStart *int64
	createTimeEnd *int64
}

// UserId
func (r SubscriptionSubscriptionListGetRequest) UserId(userId int64) SubscriptionSubscriptionListGetRequest {
	r.userId = &userId
	return r
}

// Filter, Default All，Status，1-Pending｜2-Active｜3-Suspend | 4-Cancel | 5-Expire | 6- Suspend| 7-Incomplete | 8-Processing | 9-Failed
func (r SubscriptionSubscriptionListGetRequest) Status(status []int32) SubscriptionSubscriptionListGetRequest {
	r.status = &status
	return r
}

// The currency of subscription
func (r SubscriptionSubscriptionListGetRequest) Currency(currency string) SubscriptionSubscriptionListGetRequest {
	r.currency = &currency
	return r
}

// The filter ids of plan
func (r SubscriptionSubscriptionListGetRequest) PlanIds(planIds []int64) SubscriptionSubscriptionListGetRequest {
	r.planIds = &planIds
	return r
}

// The filter ids of product
func (r SubscriptionSubscriptionListGetRequest) ProductIds(productIds []int64) SubscriptionSubscriptionListGetRequest {
	r.productIds = &productIds
	return r
}

// The filter start amount of subscription
func (r SubscriptionSubscriptionListGetRequest) AmountStart(amountStart int32) SubscriptionSubscriptionListGetRequest {
	r.amountStart = &amountStart
	return r
}

// The filter end amount of subscription
func (r SubscriptionSubscriptionListGetRequest) AmountEnd(amountEnd int32) SubscriptionSubscriptionListGetRequest {
	r.amountEnd = &amountEnd
	return r
}

// Sort Field，gmt_create|gmt_modify，Default gmt_modify
func (r SubscriptionSubscriptionListGetRequest) SortField(sortField string) SubscriptionSubscriptionListGetRequest {
	r.sortField = &sortField
	return r
}

// Sort Type，asc|desc，Default desc
func (r SubscriptionSubscriptionListGetRequest) SortType(sortType string) SubscriptionSubscriptionListGetRequest {
	r.sortType = &sortType
	return r
}

// Page, Start With 0
func (r SubscriptionSubscriptionListGetRequest) Page(page int32) SubscriptionSubscriptionListGetRequest {
	r.page = &page
	return r
}

// Count Of Page
func (r SubscriptionSubscriptionListGetRequest) Count(count int32) SubscriptionSubscriptionListGetRequest {
	r.count = &count
	return r
}

// CreateTimeStart
func (r SubscriptionSubscriptionListGetRequest) CreateTimeStart(createTimeStart int64) SubscriptionSubscriptionListGetRequest {
	r.createTimeStart = &createTimeStart
	return r
}

// CreateTimeEnd
func (r SubscriptionSubscriptionListGetRequest) CreateTimeEnd(createTimeEnd int64) SubscriptionSubscriptionListGetRequest {
	r.createTimeEnd = &createTimeEnd
	return r
}

func (r SubscriptionSubscriptionListGetRequest) Execute() (*MerchantSubscriptionListGet200Response, *http.Response, error) {
	return r.ApiService.SubscriptionListGetExecute(r)
}

/*
SubscriptionListGet SubscriptionList

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SubscriptionSubscriptionListGetRequest
*/
func (a *SubscriptionService) SubscriptionListGet(ctx context.Context) SubscriptionSubscriptionListGetRequest {
	return SubscriptionSubscriptionListGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MerchantSubscriptionListGet200Response
func (a *SubscriptionService) SubscriptionListGetExecute(r SubscriptionSubscriptionListGetRequest) (*MerchantSubscriptionListGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MerchantSubscriptionListGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubscriptionService.SubscriptionListGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/merchant/subscription/list"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.userId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "userId", r.userId, "")
	}
	if r.status != nil {
		t := *r.status
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "status", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "status", t, "multi")
		}
	}
	if r.currency != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "currency", r.currency, "")
	}
	if r.planIds != nil {
		t := *r.planIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "planIds", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "planIds", t, "multi")
		}
	}
	if r.productIds != nil {
		t := *r.productIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "productIds", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "productIds", t, "multi")
		}
	}
	if r.amountStart != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "amountStart", r.amountStart, "")
	}
	if r.amountEnd != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "amountEnd", r.amountEnd, "")
	}
	if r.sortField != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sortField", r.sortField, "")
	}
	if r.sortType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sortType", r.sortType, "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	if r.count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "count", r.count, "")
	}
	if r.createTimeStart != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "createTimeStart", r.createTimeStart, "")
	}
	if r.createTimeEnd != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "createTimeEnd", r.createTimeEnd, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SubscriptionSubscriptionListPostRequest struct {
	ctx context.Context
	ApiService *SubscriptionService
	unibeeApiMerchantSubscriptionListReq *UnibeeApiMerchantSubscriptionListReq
}

func (r SubscriptionSubscriptionListPostRequest) UnibeeApiMerchantSubscriptionListReq(unibeeApiMerchantSubscriptionListReq UnibeeApiMerchantSubscriptionListReq) SubscriptionSubscriptionListPostRequest {
	r.unibeeApiMerchantSubscriptionListReq = &unibeeApiMerchantSubscriptionListReq
	return r
}

func (r SubscriptionSubscriptionListPostRequest) Execute() (*MerchantSubscriptionListGet200Response, *http.Response, error) {
	return r.ApiService.SubscriptionListPostExecute(r)
}

/*
SubscriptionListPost SubscriptionList

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SubscriptionSubscriptionListPostRequest
*/
func (a *SubscriptionService) SubscriptionListPost(ctx context.Context) SubscriptionSubscriptionListPostRequest {
	return SubscriptionSubscriptionListPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MerchantSubscriptionListGet200Response
func (a *SubscriptionService) SubscriptionListPostExecute(r SubscriptionSubscriptionListPostRequest) (*MerchantSubscriptionListGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MerchantSubscriptionListGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubscriptionService.SubscriptionListPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/merchant/subscription/list"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.unibeeApiMerchantSubscriptionListReq == nil {
		return localVarReturnValue, nil, reportError("unibeeApiMerchantSubscriptionListReq is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.unibeeApiMerchantSubscriptionListReq
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SubscriptionSubscriptionNewOnetimeAddonPaymentPostRequest struct {
	ctx context.Context
	ApiService *SubscriptionService
	unibeeApiMerchantSubscriptionOnetimeAddonNewReq *UnibeeApiMerchantSubscriptionOnetimeAddonNewReq
}

func (r SubscriptionSubscriptionNewOnetimeAddonPaymentPostRequest) UnibeeApiMerchantSubscriptionOnetimeAddonNewReq(unibeeApiMerchantSubscriptionOnetimeAddonNewReq UnibeeApiMerchantSubscriptionOnetimeAddonNewReq) SubscriptionSubscriptionNewOnetimeAddonPaymentPostRequest {
	r.unibeeApiMerchantSubscriptionOnetimeAddonNewReq = &unibeeApiMerchantSubscriptionOnetimeAddonNewReq
	return r
}

func (r SubscriptionSubscriptionNewOnetimeAddonPaymentPostRequest) Execute() (*MerchantSubscriptionNewOnetimeAddonPaymentPost200Response, *http.Response, error) {
	return r.ApiService.SubscriptionNewOnetimeAddonPaymentPostExecute(r)
}

/*
SubscriptionNewOnetimeAddonPaymentPost NewSubscriptionOnetimeAddonPayment

Create payment for subscription onetime addon purchase

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SubscriptionSubscriptionNewOnetimeAddonPaymentPostRequest
*/
func (a *SubscriptionService) SubscriptionNewOnetimeAddonPaymentPost(ctx context.Context) SubscriptionSubscriptionNewOnetimeAddonPaymentPostRequest {
	return SubscriptionSubscriptionNewOnetimeAddonPaymentPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MerchantSubscriptionNewOnetimeAddonPaymentPost200Response
func (a *SubscriptionService) SubscriptionNewOnetimeAddonPaymentPostExecute(r SubscriptionSubscriptionNewOnetimeAddonPaymentPostRequest) (*MerchantSubscriptionNewOnetimeAddonPaymentPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MerchantSubscriptionNewOnetimeAddonPaymentPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubscriptionService.SubscriptionNewOnetimeAddonPaymentPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/merchant/subscription/new_onetime_addon_payment"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.unibeeApiMerchantSubscriptionOnetimeAddonNewReq == nil {
		return localVarReturnValue, nil, reportError("unibeeApiMerchantSubscriptionOnetimeAddonNewReq is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.unibeeApiMerchantSubscriptionOnetimeAddonNewReq
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SubscriptionSubscriptionOnetimeAddonListGetRequest struct {
	ctx context.Context
	ApiService *SubscriptionService
	userId *int64
	page *int32
	count *int32
}

// UserId
func (r SubscriptionSubscriptionOnetimeAddonListGetRequest) UserId(userId int64) SubscriptionSubscriptionOnetimeAddonListGetRequest {
	r.userId = &userId
	return r
}

// Page, Start With 0
func (r SubscriptionSubscriptionOnetimeAddonListGetRequest) Page(page int32) SubscriptionSubscriptionOnetimeAddonListGetRequest {
	r.page = &page
	return r
}

// Count Of Page
func (r SubscriptionSubscriptionOnetimeAddonListGetRequest) Count(count int32) SubscriptionSubscriptionOnetimeAddonListGetRequest {
	r.count = &count
	return r
}

func (r SubscriptionSubscriptionOnetimeAddonListGetRequest) Execute() (*MerchantSubscriptionOnetimeAddonListGet200Response, *http.Response, error) {
	return r.ApiService.SubscriptionOnetimeAddonListGetExecute(r)
}

/*
SubscriptionOnetimeAddonListGet SubscriptionOnetimeAddonList

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SubscriptionSubscriptionOnetimeAddonListGetRequest
*/
func (a *SubscriptionService) SubscriptionOnetimeAddonListGet(ctx context.Context) SubscriptionSubscriptionOnetimeAddonListGetRequest {
	return SubscriptionSubscriptionOnetimeAddonListGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MerchantSubscriptionOnetimeAddonListGet200Response
func (a *SubscriptionService) SubscriptionOnetimeAddonListGetExecute(r SubscriptionSubscriptionOnetimeAddonListGetRequest) (*MerchantSubscriptionOnetimeAddonListGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MerchantSubscriptionOnetimeAddonListGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubscriptionService.SubscriptionOnetimeAddonListGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/merchant/subscription/onetime_addon_list"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.userId == nil {
		return localVarReturnValue, nil, reportError("userId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "userId", r.userId, "")
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	if r.count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "count", r.count, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SubscriptionSubscriptionPaymentNewPostRequest struct {
	ctx context.Context
	ApiService *SubscriptionService
	unibeeApiMerchantSubscriptionNewPaymentReq *UnibeeApiMerchantSubscriptionNewPaymentReq
}

func (r SubscriptionSubscriptionPaymentNewPostRequest) UnibeeApiMerchantSubscriptionNewPaymentReq(unibeeApiMerchantSubscriptionNewPaymentReq UnibeeApiMerchantSubscriptionNewPaymentReq) SubscriptionSubscriptionPaymentNewPostRequest {
	r.unibeeApiMerchantSubscriptionNewPaymentReq = &unibeeApiMerchantSubscriptionNewPaymentReq
	return r
}

func (r SubscriptionSubscriptionPaymentNewPostRequest) Execute() (*MerchantPaymentNewPost200Response, *http.Response, error) {
	return r.ApiService.SubscriptionPaymentNewPostExecute(r)
}

/*
SubscriptionPaymentNewPost NewSubscriptionPayment

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SubscriptionSubscriptionPaymentNewPostRequest
*/
func (a *SubscriptionService) SubscriptionPaymentNewPost(ctx context.Context) SubscriptionSubscriptionPaymentNewPostRequest {
	return SubscriptionSubscriptionPaymentNewPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MerchantPaymentNewPost200Response
func (a *SubscriptionService) SubscriptionPaymentNewPostExecute(r SubscriptionSubscriptionPaymentNewPostRequest) (*MerchantPaymentNewPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MerchantPaymentNewPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubscriptionService.SubscriptionPaymentNewPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/merchant/subscription/payment/new"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.unibeeApiMerchantSubscriptionNewPaymentReq == nil {
		return localVarReturnValue, nil, reportError("unibeeApiMerchantSubscriptionNewPaymentReq is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.unibeeApiMerchantSubscriptionNewPaymentReq
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SubscriptionSubscriptionRenewPostRequest struct {
	ctx context.Context
	ApiService *SubscriptionService
	unibeeApiMerchantSubscriptionRenewReq *UnibeeApiMerchantSubscriptionRenewReq
}

func (r SubscriptionSubscriptionRenewPostRequest) UnibeeApiMerchantSubscriptionRenewReq(unibeeApiMerchantSubscriptionRenewReq UnibeeApiMerchantSubscriptionRenewReq) SubscriptionSubscriptionRenewPostRequest {
	r.unibeeApiMerchantSubscriptionRenewReq = &unibeeApiMerchantSubscriptionRenewReq
	return r
}

func (r SubscriptionSubscriptionRenewPostRequest) Execute() (*MerchantSubscriptionRenewPost200Response, *http.Response, error) {
	return r.ApiService.SubscriptionRenewPostExecute(r)
}

/*
SubscriptionRenewPost RenewSubscription

renew an exist subscription 

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SubscriptionSubscriptionRenewPostRequest
*/
func (a *SubscriptionService) SubscriptionRenewPost(ctx context.Context) SubscriptionSubscriptionRenewPostRequest {
	return SubscriptionSubscriptionRenewPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MerchantSubscriptionRenewPost200Response
func (a *SubscriptionService) SubscriptionRenewPostExecute(r SubscriptionSubscriptionRenewPostRequest) (*MerchantSubscriptionRenewPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MerchantSubscriptionRenewPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubscriptionService.SubscriptionRenewPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/merchant/subscription/renew"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.unibeeApiMerchantSubscriptionRenewReq == nil {
		return localVarReturnValue, nil, reportError("unibeeApiMerchantSubscriptionRenewReq is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.unibeeApiMerchantSubscriptionRenewReq
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SubscriptionSubscriptionResumePostRequest struct {
	ctx context.Context
	ApiService *SubscriptionService
	unibeeApiMerchantSubscriptionResumeReq *UnibeeApiMerchantSubscriptionResumeReq
}

func (r SubscriptionSubscriptionResumePostRequest) UnibeeApiMerchantSubscriptionResumeReq(unibeeApiMerchantSubscriptionResumeReq UnibeeApiMerchantSubscriptionResumeReq) SubscriptionSubscriptionResumePostRequest {
	r.unibeeApiMerchantSubscriptionResumeReq = &unibeeApiMerchantSubscriptionResumeReq
	return r
}

func (r SubscriptionSubscriptionResumePostRequest) Execute() (*MerchantAuthSsoLoginOTPPost200Response, *http.Response, error) {
	return r.ApiService.SubscriptionResumePostExecute(r)
}

/*
SubscriptionResumePost Merchant Edit Subscription-Resume

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SubscriptionSubscriptionResumePostRequest

Deprecated
*/
func (a *SubscriptionService) SubscriptionResumePost(ctx context.Context) SubscriptionSubscriptionResumePostRequest {
	return SubscriptionSubscriptionResumePostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MerchantAuthSsoLoginOTPPost200Response
// Deprecated
func (a *SubscriptionService) SubscriptionResumePostExecute(r SubscriptionSubscriptionResumePostRequest) (*MerchantAuthSsoLoginOTPPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MerchantAuthSsoLoginOTPPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubscriptionService.SubscriptionResumePost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/merchant/subscription/resume"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.unibeeApiMerchantSubscriptionResumeReq == nil {
		return localVarReturnValue, nil, reportError("unibeeApiMerchantSubscriptionResumeReq is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.unibeeApiMerchantSubscriptionResumeReq
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SubscriptionSubscriptionSuspendPostRequest struct {
	ctx context.Context
	ApiService *SubscriptionService
	unibeeApiMerchantSubscriptionSuspendReq *UnibeeApiMerchantSubscriptionSuspendReq
}

func (r SubscriptionSubscriptionSuspendPostRequest) UnibeeApiMerchantSubscriptionSuspendReq(unibeeApiMerchantSubscriptionSuspendReq UnibeeApiMerchantSubscriptionSuspendReq) SubscriptionSubscriptionSuspendPostRequest {
	r.unibeeApiMerchantSubscriptionSuspendReq = &unibeeApiMerchantSubscriptionSuspendReq
	return r
}

func (r SubscriptionSubscriptionSuspendPostRequest) Execute() (*MerchantAuthSsoLoginOTPPost200Response, *http.Response, error) {
	return r.ApiService.SubscriptionSuspendPostExecute(r)
}

/*
SubscriptionSuspendPost Merchant Edit Subscription-Stop

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SubscriptionSubscriptionSuspendPostRequest

Deprecated
*/
func (a *SubscriptionService) SubscriptionSuspendPost(ctx context.Context) SubscriptionSubscriptionSuspendPostRequest {
	return SubscriptionSubscriptionSuspendPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MerchantAuthSsoLoginOTPPost200Response
// Deprecated
func (a *SubscriptionService) SubscriptionSuspendPostExecute(r SubscriptionSubscriptionSuspendPostRequest) (*MerchantAuthSsoLoginOTPPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MerchantAuthSsoLoginOTPPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubscriptionService.SubscriptionSuspendPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/merchant/subscription/suspend"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.unibeeApiMerchantSubscriptionSuspendReq == nil {
		return localVarReturnValue, nil, reportError("unibeeApiMerchantSubscriptionSuspendReq is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.unibeeApiMerchantSubscriptionSuspendReq
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SubscriptionSubscriptionUpdatePreviewPostRequest struct {
	ctx context.Context
	ApiService *SubscriptionService
	unibeeApiMerchantSubscriptionUpdatePreviewReq *UnibeeApiMerchantSubscriptionUpdatePreviewReq
}

func (r SubscriptionSubscriptionUpdatePreviewPostRequest) UnibeeApiMerchantSubscriptionUpdatePreviewReq(unibeeApiMerchantSubscriptionUpdatePreviewReq UnibeeApiMerchantSubscriptionUpdatePreviewReq) SubscriptionSubscriptionUpdatePreviewPostRequest {
	r.unibeeApiMerchantSubscriptionUpdatePreviewReq = &unibeeApiMerchantSubscriptionUpdatePreviewReq
	return r
}

func (r SubscriptionSubscriptionUpdatePreviewPostRequest) Execute() (*MerchantSubscriptionUpdatePreviewPost200Response, *http.Response, error) {
	return r.ApiService.SubscriptionUpdatePreviewPostExecute(r)
}

/*
SubscriptionUpdatePreviewPost UpdateSubscriptionPreview

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SubscriptionSubscriptionUpdatePreviewPostRequest
*/
func (a *SubscriptionService) SubscriptionUpdatePreviewPost(ctx context.Context) SubscriptionSubscriptionUpdatePreviewPostRequest {
	return SubscriptionSubscriptionUpdatePreviewPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MerchantSubscriptionUpdatePreviewPost200Response
func (a *SubscriptionService) SubscriptionUpdatePreviewPostExecute(r SubscriptionSubscriptionUpdatePreviewPostRequest) (*MerchantSubscriptionUpdatePreviewPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MerchantSubscriptionUpdatePreviewPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubscriptionService.SubscriptionUpdatePreviewPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/merchant/subscription/update_preview"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.unibeeApiMerchantSubscriptionUpdatePreviewReq == nil {
		return localVarReturnValue, nil, reportError("unibeeApiMerchantSubscriptionUpdatePreviewReq is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.unibeeApiMerchantSubscriptionUpdatePreviewReq
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SubscriptionSubscriptionUpdateSubmitPostRequest struct {
	ctx context.Context
	ApiService *SubscriptionService
	unibeeApiMerchantSubscriptionUpdateReq *UnibeeApiMerchantSubscriptionUpdateReq
}

func (r SubscriptionSubscriptionUpdateSubmitPostRequest) UnibeeApiMerchantSubscriptionUpdateReq(unibeeApiMerchantSubscriptionUpdateReq UnibeeApiMerchantSubscriptionUpdateReq) SubscriptionSubscriptionUpdateSubmitPostRequest {
	r.unibeeApiMerchantSubscriptionUpdateReq = &unibeeApiMerchantSubscriptionUpdateReq
	return r
}

func (r SubscriptionSubscriptionUpdateSubmitPostRequest) Execute() (*MerchantSubscriptionUpdateSubmitPost200Response, *http.Response, error) {
	return r.ApiService.SubscriptionUpdateSubmitPostExecute(r)
}

/*
SubscriptionUpdateSubmitPost UpdateSubscription

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SubscriptionSubscriptionUpdateSubmitPostRequest
*/
func (a *SubscriptionService) SubscriptionUpdateSubmitPost(ctx context.Context) SubscriptionSubscriptionUpdateSubmitPostRequest {
	return SubscriptionSubscriptionUpdateSubmitPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MerchantSubscriptionUpdateSubmitPost200Response
func (a *SubscriptionService) SubscriptionUpdateSubmitPostExecute(r SubscriptionSubscriptionUpdateSubmitPostRequest) (*MerchantSubscriptionUpdateSubmitPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MerchantSubscriptionUpdateSubmitPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubscriptionService.SubscriptionUpdateSubmitPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/merchant/subscription/update_submit"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.unibeeApiMerchantSubscriptionUpdateReq == nil {
		return localVarReturnValue, nil, reportError("unibeeApiMerchantSubscriptionUpdateReq is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.unibeeApiMerchantSubscriptionUpdateReq
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SubscriptionSubscriptionUserPendingCryptoSubscriptionDetailGetRequest struct {
	ctx context.Context
	ApiService *SubscriptionService
	userId *int64
	externalUserId *string
	productId *int64
}

// UserId
func (r SubscriptionSubscriptionUserPendingCryptoSubscriptionDetailGetRequest) UserId(userId int64) SubscriptionSubscriptionUserPendingCryptoSubscriptionDetailGetRequest {
	r.userId = &userId
	return r
}

// ExternalUserId, unique, either ExternalUserId&amp;Email or UserId needed
func (r SubscriptionSubscriptionUserPendingCryptoSubscriptionDetailGetRequest) ExternalUserId(externalUserId string) SubscriptionSubscriptionUserPendingCryptoSubscriptionDetailGetRequest {
	r.externalUserId = &externalUserId
	return r
}

// default product will use if productId not specified and subscriptionId is blank
func (r SubscriptionSubscriptionUserPendingCryptoSubscriptionDetailGetRequest) ProductId(productId int64) SubscriptionSubscriptionUserPendingCryptoSubscriptionDetailGetRequest {
	r.productId = &productId
	return r
}

func (r SubscriptionSubscriptionUserPendingCryptoSubscriptionDetailGetRequest) Execute() (*MerchantSubscriptionUserPendingCryptoSubscriptionDetailGet200Response, *http.Response, error) {
	return r.ApiService.SubscriptionUserPendingCryptoSubscriptionDetailGetExecute(r)
}

/*
SubscriptionUserPendingCryptoSubscriptionDetailGet UserPendingCryptoSubscriptionDetail

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SubscriptionSubscriptionUserPendingCryptoSubscriptionDetailGetRequest
*/
func (a *SubscriptionService) SubscriptionUserPendingCryptoSubscriptionDetailGet(ctx context.Context) SubscriptionSubscriptionUserPendingCryptoSubscriptionDetailGetRequest {
	return SubscriptionSubscriptionUserPendingCryptoSubscriptionDetailGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MerchantSubscriptionUserPendingCryptoSubscriptionDetailGet200Response
func (a *SubscriptionService) SubscriptionUserPendingCryptoSubscriptionDetailGetExecute(r SubscriptionSubscriptionUserPendingCryptoSubscriptionDetailGetRequest) (*MerchantSubscriptionUserPendingCryptoSubscriptionDetailGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MerchantSubscriptionUserPendingCryptoSubscriptionDetailGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubscriptionService.SubscriptionUserPendingCryptoSubscriptionDetailGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/merchant/subscription/user_pending_crypto_subscription_detail"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.userId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "userId", r.userId, "")
	}
	if r.externalUserId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "externalUserId", r.externalUserId, "")
	}
	if r.productId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "productId", r.productId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SubscriptionSubscriptionUserPendingCryptoSubscriptionDetailPostRequest struct {
	ctx context.Context
	ApiService *SubscriptionService
	unibeeApiMerchantSubscriptionUserPendingCryptoSubscriptionDetailReq *UnibeeApiMerchantSubscriptionUserPendingCryptoSubscriptionDetailReq
}

func (r SubscriptionSubscriptionUserPendingCryptoSubscriptionDetailPostRequest) UnibeeApiMerchantSubscriptionUserPendingCryptoSubscriptionDetailReq(unibeeApiMerchantSubscriptionUserPendingCryptoSubscriptionDetailReq UnibeeApiMerchantSubscriptionUserPendingCryptoSubscriptionDetailReq) SubscriptionSubscriptionUserPendingCryptoSubscriptionDetailPostRequest {
	r.unibeeApiMerchantSubscriptionUserPendingCryptoSubscriptionDetailReq = &unibeeApiMerchantSubscriptionUserPendingCryptoSubscriptionDetailReq
	return r
}

func (r SubscriptionSubscriptionUserPendingCryptoSubscriptionDetailPostRequest) Execute() (*MerchantSubscriptionUserPendingCryptoSubscriptionDetailGet200Response, *http.Response, error) {
	return r.ApiService.SubscriptionUserPendingCryptoSubscriptionDetailPostExecute(r)
}

/*
SubscriptionUserPendingCryptoSubscriptionDetailPost UserPendingCryptoSubscriptionDetail

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SubscriptionSubscriptionUserPendingCryptoSubscriptionDetailPostRequest
*/
func (a *SubscriptionService) SubscriptionUserPendingCryptoSubscriptionDetailPost(ctx context.Context) SubscriptionSubscriptionUserPendingCryptoSubscriptionDetailPostRequest {
	return SubscriptionSubscriptionUserPendingCryptoSubscriptionDetailPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MerchantSubscriptionUserPendingCryptoSubscriptionDetailGet200Response
func (a *SubscriptionService) SubscriptionUserPendingCryptoSubscriptionDetailPostExecute(r SubscriptionSubscriptionUserPendingCryptoSubscriptionDetailPostRequest) (*MerchantSubscriptionUserPendingCryptoSubscriptionDetailGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MerchantSubscriptionUserPendingCryptoSubscriptionDetailGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubscriptionService.SubscriptionUserPendingCryptoSubscriptionDetailPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/merchant/subscription/user_pending_crypto_subscription_detail"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.unibeeApiMerchantSubscriptionUserPendingCryptoSubscriptionDetailReq == nil {
		return localVarReturnValue, nil, reportError("unibeeApiMerchantSubscriptionUserPendingCryptoSubscriptionDetailReq is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.unibeeApiMerchantSubscriptionUserPendingCryptoSubscriptionDetailReq
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SubscriptionSubscriptionUserSubscriptionDetailGetRequest struct {
	ctx context.Context
	ApiService *SubscriptionService
	userId *int64
	externalUserId *string
	productId *int64
}

// UserId
func (r SubscriptionSubscriptionUserSubscriptionDetailGetRequest) UserId(userId int64) SubscriptionSubscriptionUserSubscriptionDetailGetRequest {
	r.userId = &userId
	return r
}

// ExternalUserId, unique, either ExternalUserId&amp;Email or UserId needed
func (r SubscriptionSubscriptionUserSubscriptionDetailGetRequest) ExternalUserId(externalUserId string) SubscriptionSubscriptionUserSubscriptionDetailGetRequest {
	r.externalUserId = &externalUserId
	return r
}

// default product will use if productId not specified and subscriptionId is blank
func (r SubscriptionSubscriptionUserSubscriptionDetailGetRequest) ProductId(productId int64) SubscriptionSubscriptionUserSubscriptionDetailGetRequest {
	r.productId = &productId
	return r
}

func (r SubscriptionSubscriptionUserSubscriptionDetailGetRequest) Execute() (*MerchantSubscriptionUserSubscriptionDetailGet200Response, *http.Response, error) {
	return r.ApiService.SubscriptionUserSubscriptionDetailGetExecute(r)
}

/*
SubscriptionUserSubscriptionDetailGet UserSubscriptionDetail

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SubscriptionSubscriptionUserSubscriptionDetailGetRequest
*/
func (a *SubscriptionService) SubscriptionUserSubscriptionDetailGet(ctx context.Context) SubscriptionSubscriptionUserSubscriptionDetailGetRequest {
	return SubscriptionSubscriptionUserSubscriptionDetailGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MerchantSubscriptionUserSubscriptionDetailGet200Response
func (a *SubscriptionService) SubscriptionUserSubscriptionDetailGetExecute(r SubscriptionSubscriptionUserSubscriptionDetailGetRequest) (*MerchantSubscriptionUserSubscriptionDetailGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MerchantSubscriptionUserSubscriptionDetailGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubscriptionService.SubscriptionUserSubscriptionDetailGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/merchant/subscription/user_subscription_detail"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.userId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "userId", r.userId, "")
	}
	if r.externalUserId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "externalUserId", r.externalUserId, "")
	}
	if r.productId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "productId", r.productId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SubscriptionSubscriptionUserSubscriptionDetailPostRequest struct {
	ctx context.Context
	ApiService *SubscriptionService
	unibeeApiMerchantSubscriptionUserSubscriptionDetailReq *UnibeeApiMerchantSubscriptionUserSubscriptionDetailReq
}

func (r SubscriptionSubscriptionUserSubscriptionDetailPostRequest) UnibeeApiMerchantSubscriptionUserSubscriptionDetailReq(unibeeApiMerchantSubscriptionUserSubscriptionDetailReq UnibeeApiMerchantSubscriptionUserSubscriptionDetailReq) SubscriptionSubscriptionUserSubscriptionDetailPostRequest {
	r.unibeeApiMerchantSubscriptionUserSubscriptionDetailReq = &unibeeApiMerchantSubscriptionUserSubscriptionDetailReq
	return r
}

func (r SubscriptionSubscriptionUserSubscriptionDetailPostRequest) Execute() (*MerchantSubscriptionUserSubscriptionDetailGet200Response, *http.Response, error) {
	return r.ApiService.SubscriptionUserSubscriptionDetailPostExecute(r)
}

/*
SubscriptionUserSubscriptionDetailPost UserSubscriptionDetail

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SubscriptionSubscriptionUserSubscriptionDetailPostRequest
*/
func (a *SubscriptionService) SubscriptionUserSubscriptionDetailPost(ctx context.Context) SubscriptionSubscriptionUserSubscriptionDetailPostRequest {
	return SubscriptionSubscriptionUserSubscriptionDetailPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MerchantSubscriptionUserSubscriptionDetailGet200Response
func (a *SubscriptionService) SubscriptionUserSubscriptionDetailPostExecute(r SubscriptionSubscriptionUserSubscriptionDetailPostRequest) (*MerchantSubscriptionUserSubscriptionDetailGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MerchantSubscriptionUserSubscriptionDetailGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubscriptionService.SubscriptionUserSubscriptionDetailPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/merchant/subscription/user_subscription_detail"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.unibeeApiMerchantSubscriptionUserSubscriptionDetailReq == nil {
		return localVarReturnValue, nil, reportError("unibeeApiMerchantSubscriptionUserSubscriptionDetailReq is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.unibeeApiMerchantSubscriptionUserSubscriptionDetailReq
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

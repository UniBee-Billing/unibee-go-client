/*
OpenAPI UniBee

UniBee Api Server

API version: daily,buildtime:202504011414
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package unibee

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"reflect"
)


// SubscriptionService Subscription service
type SubscriptionService service

type SubscriptionSubscriptionAddNewTrialStartPostRequest struct {
	ctx context.Context
	ApiService *SubscriptionService
	unibeeApiMerchantSubscriptionAddNewTrialStartReq *UnibeeApiMerchantSubscriptionAddNewTrialStartReq
}

func (r SubscriptionSubscriptionAddNewTrialStartPostRequest) UnibeeApiMerchantSubscriptionAddNewTrialStartReq(unibeeApiMerchantSubscriptionAddNewTrialStartReq UnibeeApiMerchantSubscriptionAddNewTrialStartReq) SubscriptionSubscriptionAddNewTrialStartPostRequest {
	r.unibeeApiMerchantSubscriptionAddNewTrialStartReq = &unibeeApiMerchantSubscriptionAddNewTrialStartReq
	return r
}

func (r SubscriptionSubscriptionAddNewTrialStartPostRequest) Execute() (*MerchantAuthSsoLoginOTPPost200Response, *http.Response, error) {
	return r.ApiService.SubscriptionAddNewTrialStartPostExecute(r)
}

/*
SubscriptionAddNewTrialStartPost Append Subscription TrialEnd

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SubscriptionSubscriptionAddNewTrialStartPostRequest
*/
func (a *SubscriptionService) SubscriptionAddNewTrialStartPost(ctx context.Context) SubscriptionSubscriptionAddNewTrialStartPostRequest {
	return SubscriptionSubscriptionAddNewTrialStartPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MerchantAuthSsoLoginOTPPost200Response
func (a *SubscriptionService) SubscriptionAddNewTrialStartPostExecute(r SubscriptionSubscriptionAddNewTrialStartPostRequest) (*MerchantAuthSsoLoginOTPPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MerchantAuthSsoLoginOTPPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubscriptionService.SubscriptionAddNewTrialStartPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/merchant/subscription/add_new_trial_start"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.unibeeApiMerchantSubscriptionAddNewTrialStartReq == nil {
		return localVarReturnValue, nil, reportError("unibeeApiMerchantSubscriptionAddNewTrialStartReq is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.unibeeApiMerchantSubscriptionAddNewTrialStartReq
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SubscriptionSubscriptionCancelAtPeriodEndPostRequest struct {
	ctx context.Context
	ApiService *SubscriptionService
	unibeeApiMerchantSubscriptionCancelAtPeriodEndReq *UnibeeApiMerchantSubscriptionCancelAtPeriodEndReq
}

func (r SubscriptionSubscriptionCancelAtPeriodEndPostRequest) UnibeeApiMerchantSubscriptionCancelAtPeriodEndReq(unibeeApiMerchantSubscriptionCancelAtPeriodEndReq UnibeeApiMerchantSubscriptionCancelAtPeriodEndReq) SubscriptionSubscriptionCancelAtPeriodEndPostRequest {
	r.unibeeApiMerchantSubscriptionCancelAtPeriodEndReq = &unibeeApiMerchantSubscriptionCancelAtPeriodEndReq
	return r
}

func (r SubscriptionSubscriptionCancelAtPeriodEndPostRequest) Execute() (*MerchantAuthSsoLoginOTPPost200Response, *http.Response, error) {
	return r.ApiService.SubscriptionCancelAtPeriodEndPostExecute(r)
}

/*
SubscriptionCancelAtPeriodEndPost Cancel Subscription At Period End

Cancel subscription at period end, the subscription will not turn to 'cancelled' at once but will cancelled at period end time, no invoice will generate, the flag 'cancelAtPeriodEnd' of subscription will be enabled

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SubscriptionSubscriptionCancelAtPeriodEndPostRequest
*/
func (a *SubscriptionService) SubscriptionCancelAtPeriodEndPost(ctx context.Context) SubscriptionSubscriptionCancelAtPeriodEndPostRequest {
	return SubscriptionSubscriptionCancelAtPeriodEndPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MerchantAuthSsoLoginOTPPost200Response
func (a *SubscriptionService) SubscriptionCancelAtPeriodEndPostExecute(r SubscriptionSubscriptionCancelAtPeriodEndPostRequest) (*MerchantAuthSsoLoginOTPPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MerchantAuthSsoLoginOTPPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubscriptionService.SubscriptionCancelAtPeriodEndPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/merchant/subscription/cancel_at_period_end"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.unibeeApiMerchantSubscriptionCancelAtPeriodEndReq == nil {
		return localVarReturnValue, nil, reportError("unibeeApiMerchantSubscriptionCancelAtPeriodEndReq is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.unibeeApiMerchantSubscriptionCancelAtPeriodEndReq
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SubscriptionSubscriptionCancelLastCancelAtPeriodEndPostRequest struct {
	ctx context.Context
	ApiService *SubscriptionService
	unibeeApiMerchantSubscriptionCancelLastCancelAtPeriodEndReq *UnibeeApiMerchantSubscriptionCancelLastCancelAtPeriodEndReq
}

func (r SubscriptionSubscriptionCancelLastCancelAtPeriodEndPostRequest) UnibeeApiMerchantSubscriptionCancelLastCancelAtPeriodEndReq(unibeeApiMerchantSubscriptionCancelLastCancelAtPeriodEndReq UnibeeApiMerchantSubscriptionCancelLastCancelAtPeriodEndReq) SubscriptionSubscriptionCancelLastCancelAtPeriodEndPostRequest {
	r.unibeeApiMerchantSubscriptionCancelLastCancelAtPeriodEndReq = &unibeeApiMerchantSubscriptionCancelLastCancelAtPeriodEndReq
	return r
}

func (r SubscriptionSubscriptionCancelLastCancelAtPeriodEndPostRequest) Execute() (*MerchantAuthSsoLoginOTPPost200Response, *http.Response, error) {
	return r.ApiService.SubscriptionCancelLastCancelAtPeriodEndPostExecute(r)
}

/*
SubscriptionCancelLastCancelAtPeriodEndPost Cancel Last Cancel Subscription At Period End

This action should be request before subscription's period end, If subscription's flag 'cancelAtPeriodEnd' is enabled, this action will resume it to disable, and subscription will continue cycle recurring seems no cancelAtPeriod action be setting

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SubscriptionSubscriptionCancelLastCancelAtPeriodEndPostRequest
*/
func (a *SubscriptionService) SubscriptionCancelLastCancelAtPeriodEndPost(ctx context.Context) SubscriptionSubscriptionCancelLastCancelAtPeriodEndPostRequest {
	return SubscriptionSubscriptionCancelLastCancelAtPeriodEndPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MerchantAuthSsoLoginOTPPost200Response
func (a *SubscriptionService) SubscriptionCancelLastCancelAtPeriodEndPostExecute(r SubscriptionSubscriptionCancelLastCancelAtPeriodEndPostRequest) (*MerchantAuthSsoLoginOTPPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MerchantAuthSsoLoginOTPPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubscriptionService.SubscriptionCancelLastCancelAtPeriodEndPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/merchant/subscription/cancel_last_cancel_at_period_end"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.unibeeApiMerchantSubscriptionCancelLastCancelAtPeriodEndReq == nil {
		return localVarReturnValue, nil, reportError("unibeeApiMerchantSubscriptionCancelLastCancelAtPeriodEndReq is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.unibeeApiMerchantSubscriptionCancelLastCancelAtPeriodEndReq
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SubscriptionSubscriptionCancelPostRequest struct {
	ctx context.Context
	ApiService *SubscriptionService
	unibeeApiMerchantSubscriptionCancelReq *UnibeeApiMerchantSubscriptionCancelReq
}

func (r SubscriptionSubscriptionCancelPostRequest) UnibeeApiMerchantSubscriptionCancelReq(unibeeApiMerchantSubscriptionCancelReq UnibeeApiMerchantSubscriptionCancelReq) SubscriptionSubscriptionCancelPostRequest {
	r.unibeeApiMerchantSubscriptionCancelReq = &unibeeApiMerchantSubscriptionCancelReq
	return r
}

func (r SubscriptionSubscriptionCancelPostRequest) Execute() (*MerchantAuthSsoLoginOTPPost200Response, *http.Response, error) {
	return r.ApiService.SubscriptionCancelPostExecute(r)
}

/*
SubscriptionCancelPost Cancel Subscription Immediately

Cancel subscription immediately, no proration invoice will generate

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SubscriptionSubscriptionCancelPostRequest
*/
func (a *SubscriptionService) SubscriptionCancelPost(ctx context.Context) SubscriptionSubscriptionCancelPostRequest {
	return SubscriptionSubscriptionCancelPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MerchantAuthSsoLoginOTPPost200Response
func (a *SubscriptionService) SubscriptionCancelPostExecute(r SubscriptionSubscriptionCancelPostRequest) (*MerchantAuthSsoLoginOTPPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MerchantAuthSsoLoginOTPPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubscriptionService.SubscriptionCancelPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/merchant/subscription/cancel"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.unibeeApiMerchantSubscriptionCancelReq == nil {
		return localVarReturnValue, nil, reportError("unibeeApiMerchantSubscriptionCancelReq is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.unibeeApiMerchantSubscriptionCancelReq
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SubscriptionSubscriptionChangeGatewayPostRequest struct {
	ctx context.Context
	ApiService *SubscriptionService
	unibeeApiMerchantSubscriptionChangeGatewayReq *UnibeeApiMerchantSubscriptionChangeGatewayReq
}

func (r SubscriptionSubscriptionChangeGatewayPostRequest) UnibeeApiMerchantSubscriptionChangeGatewayReq(unibeeApiMerchantSubscriptionChangeGatewayReq UnibeeApiMerchantSubscriptionChangeGatewayReq) SubscriptionSubscriptionChangeGatewayPostRequest {
	r.unibeeApiMerchantSubscriptionChangeGatewayReq = &unibeeApiMerchantSubscriptionChangeGatewayReq
	return r
}

func (r SubscriptionSubscriptionChangeGatewayPostRequest) Execute() (*MerchantAuthSsoLoginOTPPost200Response, *http.Response, error) {
	return r.ApiService.SubscriptionChangeGatewayPostExecute(r)
}

/*
SubscriptionChangeGatewayPost Change Subscription Gateway

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SubscriptionSubscriptionChangeGatewayPostRequest
*/
func (a *SubscriptionService) SubscriptionChangeGatewayPost(ctx context.Context) SubscriptionSubscriptionChangeGatewayPostRequest {
	return SubscriptionSubscriptionChangeGatewayPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MerchantAuthSsoLoginOTPPost200Response
func (a *SubscriptionService) SubscriptionChangeGatewayPostExecute(r SubscriptionSubscriptionChangeGatewayPostRequest) (*MerchantAuthSsoLoginOTPPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MerchantAuthSsoLoginOTPPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubscriptionService.SubscriptionChangeGatewayPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/merchant/subscription/change_gateway"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.unibeeApiMerchantSubscriptionChangeGatewayReq == nil {
		return localVarReturnValue, nil, reportError("unibeeApiMerchantSubscriptionChangeGatewayReq is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.unibeeApiMerchantSubscriptionChangeGatewayReq
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SubscriptionSubscriptionCreatePreviewPostRequest struct {
	ctx context.Context
	ApiService *SubscriptionService
	unibeeApiMerchantSubscriptionCreatePreviewReq *UnibeeApiMerchantSubscriptionCreatePreviewReq
}

func (r SubscriptionSubscriptionCreatePreviewPostRequest) UnibeeApiMerchantSubscriptionCreatePreviewReq(unibeeApiMerchantSubscriptionCreatePreviewReq UnibeeApiMerchantSubscriptionCreatePreviewReq) SubscriptionSubscriptionCreatePreviewPostRequest {
	r.unibeeApiMerchantSubscriptionCreatePreviewReq = &unibeeApiMerchantSubscriptionCreatePreviewReq
	return r
}

func (r SubscriptionSubscriptionCreatePreviewPostRequest) Execute() (*MerchantSubscriptionCreatePreviewPost200Response, *http.Response, error) {
	return r.ApiService.SubscriptionCreatePreviewPostExecute(r)
}

/*
SubscriptionCreatePreviewPost Create Subscription Preview

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SubscriptionSubscriptionCreatePreviewPostRequest
*/
func (a *SubscriptionService) SubscriptionCreatePreviewPost(ctx context.Context) SubscriptionSubscriptionCreatePreviewPostRequest {
	return SubscriptionSubscriptionCreatePreviewPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MerchantSubscriptionCreatePreviewPost200Response
func (a *SubscriptionService) SubscriptionCreatePreviewPostExecute(r SubscriptionSubscriptionCreatePreviewPostRequest) (*MerchantSubscriptionCreatePreviewPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MerchantSubscriptionCreatePreviewPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubscriptionService.SubscriptionCreatePreviewPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/merchant/subscription/create_preview"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.unibeeApiMerchantSubscriptionCreatePreviewReq == nil {
		return localVarReturnValue, nil, reportError("unibeeApiMerchantSubscriptionCreatePreviewReq is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.unibeeApiMerchantSubscriptionCreatePreviewReq
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SubscriptionSubscriptionCreateSubmitPostRequest struct {
	ctx context.Context
	ApiService *SubscriptionService
	unibeeApiMerchantSubscriptionCreateReq *UnibeeApiMerchantSubscriptionCreateReq
}

func (r SubscriptionSubscriptionCreateSubmitPostRequest) UnibeeApiMerchantSubscriptionCreateReq(unibeeApiMerchantSubscriptionCreateReq UnibeeApiMerchantSubscriptionCreateReq) SubscriptionSubscriptionCreateSubmitPostRequest {
	r.unibeeApiMerchantSubscriptionCreateReq = &unibeeApiMerchantSubscriptionCreateReq
	return r
}

func (r SubscriptionSubscriptionCreateSubmitPostRequest) Execute() (*MerchantSubscriptionCreateSubmitPost200Response, *http.Response, error) {
	return r.ApiService.SubscriptionCreateSubmitPostExecute(r)
}

/*
SubscriptionCreateSubmitPost Create Subscription

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SubscriptionSubscriptionCreateSubmitPostRequest
*/
func (a *SubscriptionService) SubscriptionCreateSubmitPost(ctx context.Context) SubscriptionSubscriptionCreateSubmitPostRequest {
	return SubscriptionSubscriptionCreateSubmitPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MerchantSubscriptionCreateSubmitPost200Response
func (a *SubscriptionService) SubscriptionCreateSubmitPostExecute(r SubscriptionSubscriptionCreateSubmitPostRequest) (*MerchantSubscriptionCreateSubmitPost200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MerchantSubscriptionCreateSubmitPost200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubscriptionService.SubscriptionCreateSubmitPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/merchant/subscription/create_submit"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.unibeeApiMerchantSubscriptionCreateReq == nil {
		return localVarReturnValue, nil, reportError("unibeeApiMerchantSubscriptionCreateReq is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.unibeeApiMerchantSubscriptionCreateReq
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SubscriptionSubscriptionDetailGetRequest struct {
	ctx context.Context
	ApiService *SubscriptionService
	subscriptionId *string
}

// SubscriptionId
func (r SubscriptionSubscriptionDetailGetRequest) SubscriptionId(subscriptionId string) SubscriptionSubscriptionDetailGetRequest {
	r.subscriptionId = &subscriptionId
	return r
}

func (r SubscriptionSubscriptionDetailGetRequest) Execute() (*MerchantSubscriptionDetailGet200Response, *http.Response, error) {
	return r.ApiService.SubscriptionDetailGetExecute(r)
}

/*
SubscriptionDetailGet Subscription Detail

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SubscriptionSubscriptionDetailGetRequest
*/
func (a *SubscriptionService) SubscriptionDetailGet(ctx context.Context) SubscriptionSubscriptionDetailGetRequest {
	return SubscriptionSubscriptionDetailGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MerchantSubscriptionDetailGet200Response
func (a *SubscriptionService) SubscriptionDetailGetExecute(r SubscriptionSubscriptionDetailGetRequest) (*MerchantSubscriptionDetailGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MerchantSubscriptionDetailGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubscriptionService.SubscriptionDetailGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/merchant/subscription/detail"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.subscriptionId == nil {
		return localVarReturnValue, nil, reportError("subscriptionId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "subscriptionId", r.subscriptionId, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SubscriptionSubscriptionDetailPostRequest struct {
	ctx context.Context
	ApiService *SubscriptionService
	unibeeApiMerchantSubscriptionDetailReq *UnibeeApiMerchantSubscriptionDetailReq
}

func (r SubscriptionSubscriptionDetailPostRequest) UnibeeApiMerchantSubscriptionDetailReq(unibeeApiMerchantSubscriptionDetailReq UnibeeApiMerchantSubscriptionDetailReq) SubscriptionSubscriptionDetailPostRequest {
	r.unibeeApiMerchantSubscriptionDetailReq = &unibeeApiMerchantSubscriptionDetailReq
	return r
}

func (r SubscriptionSubscriptionDetailPostRequest) Execute() (*MerchantSubscriptionDetailGet200Response, *http.Response, error) {
	return r.ApiService.SubscriptionDetailPostExecute(r)
}

/*
SubscriptionDetailPost Subscription Detail

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SubscriptionSubscriptionDetailPostRequest
*/
func (a *SubscriptionService) SubscriptionDetailPost(ctx context.Context) SubscriptionSubscriptionDetailPostRequest {
	return SubscriptionSubscriptionDetailPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MerchantSubscriptionDetailGet200Response
func (a *SubscriptionService) SubscriptionDetailPostExecute(r SubscriptionSubscriptionDetailPostRequest) (*MerchantSubscriptionDetailGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MerchantSubscriptionDetailGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubscriptionService.SubscriptionDetailPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/merchant/subscription/detail"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.unibeeApiMerchantSubscriptionDetailReq == nil {
		return localVarReturnValue, nil, reportError("unibeeApiMerchantSubscriptionDetailReq is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.unibeeApiMerchantSubscriptionDetailReq
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SubscriptionSubscriptionListGetRequest struct {
	ctx context.Context
	ApiService *SubscriptionService
	userId *int64
	status *[]int32
	currency *string
	planIds *[]int64
	productIds *[]int64
	amountStart *int32
	amountEnd *int32
	sortField *string
	sortType *string
	page *int32
	count *int32
	createTimeStart *int64
	createTimeEnd *int64
}

// UserId
func (r SubscriptionSubscriptionListGetRequest) UserId(userId int64) SubscriptionSubscriptionListGetRequest {
	r.userId = &userId
	return r
}

// Filter, Default All，Status，1-Pending｜2-Active｜3-Suspend | 4-Cancel | 5-Expire | 6- Suspend| 7-Incomplete | 8-Processing | 9-Failed
func (r SubscriptionSubscriptionListGetRequest) Status(status []int32) SubscriptionSubscriptionListGetRequest {
	r.status = &status
	return r
}

// The currency of subscription
func (r SubscriptionSubscriptionListGetRequest) Currency(currency string) SubscriptionSubscriptionListGetRequest {
	r.currency = &currency
	return r
}

// The filter ids of plan
func (r SubscriptionSubscriptionListGetRequest) PlanIds(planIds []int64) SubscriptionSubscriptionListGetRequest {
	r.planIds = &planIds
	return r
}

// The filter ids of product
func (r SubscriptionSubscriptionListGetRequest) ProductIds(productIds []int64) SubscriptionSubscriptionListGetRequest {
	r.productIds = &productIds
	return r
}

// The filter start amount of subscription
func (r SubscriptionSubscriptionListGetRequest) AmountStart(amountStart int32) SubscriptionSubscriptionListGetRequest {
	r.amountStart = &amountStart
	return r
}

// The filter end amount of subscription
func (r SubscriptionSubscriptionListGetRequest) AmountEnd(amountEnd int32) SubscriptionSubscriptionListGetRequest {
	r.amountEnd = &amountEnd
	return r
}

// Sort Field，gmt_create|gmt_modify，Default gmt_modify
func (r SubscriptionSubscriptionListGetRequest) SortField(sortField string) SubscriptionSubscriptionListGetRequest {
	r.sortField = &sortField
	return r
}

// Sort Type，asc|desc，Default desc
func (r SubscriptionSubscriptionListGetRequest) SortType(sortType string) SubscriptionSubscriptionListGetRequest {
	r.sortType = &sortType
	return r
}

// Page, Start With 0
func (r SubscriptionSubscriptionListGetRequest) Page(page int32) SubscriptionSubscriptionListGetRequest {
	r.page = &page
	return r
}

// Count Of Page
func (r SubscriptionSubscriptionListGetRequest) Count(count int32) SubscriptionSubscriptionListGetRequest {
	r.count = &count
	return r
}

// CreateTimeStart
func (r SubscriptionSubscriptionListGetRequest) CreateTimeStart(createTimeStart int64) SubscriptionSubscriptionListGetRequest {
	r.createTimeStart = &createTimeStart
	return r
}

// CreateTimeEnd
func (r SubscriptionSubscriptionListGetRequest) CreateTimeEnd(createTimeEnd int64) SubscriptionSubscriptionListGetRequest {
	r.createTimeEnd = &createTimeEnd
	return r
}

func (r SubscriptionSubscriptionListGetRequest) Execute() (*MerchantSubscriptionListGet200Response, *http.Response, error) {
	return r.ApiService.SubscriptionListGetExecute(r)
}

/*
SubscriptionListGet Get Subscription List

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SubscriptionSubscriptionListGetRequest
*/
func (a *SubscriptionService) SubscriptionListGet(ctx context.Context) SubscriptionSubscriptionListGetRequest {
	return SubscriptionSubscriptionListGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MerchantSubscriptionListGet200Response
func (a *SubscriptionService) SubscriptionListGetExecute(r SubscriptionSubscriptionListGetRequest) (*MerchantSubscriptionListGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MerchantSubscriptionListGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubscriptionService.SubscriptionListGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/merchant/subscription/list"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.userId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "userId", r.userId, "")
	}
	if r.status != nil {
		t := *r.status
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "status", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "status", t, "multi")
		}
	}
	if r.currency != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "currency", r.currency, "")
	}
	if r.planIds != nil {
		t := *r.planIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "planIds", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "planIds", t, "multi")
		}
	}
	if r.productIds != nil {
		t := *r.productIds
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "productIds", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "productIds", t, "multi")
		}
	}
	if r.amountStart != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "amountStart", r.amountStart, "")
	}
	if r.amountEnd != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "amountEnd", r.amountEnd, "")
	}
	if r.sortField != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sortField", r.sortField, "")
	}
	if r.sortType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "sortType", r.sortType, "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	if r.count != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "count", r.count, "")
	}
	if r.createTimeStart != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "createTimeStart", r.createTimeStart, "")
	}
	if r.createTimeEnd != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "createTimeEnd", r.createTimeEnd, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SubscriptionSubscriptionListPostRequest struct {
	ctx context.Context
	ApiService *SubscriptionService
	unibeeApiMerchantSubscriptionListReq *UnibeeApiMerchantSubscriptionListReq
}

func (r SubscriptionSubscriptionListPostRequest) UnibeeApiMerchantSubscriptionListReq(unibeeApiMerchantSubscriptionListReq UnibeeApiMerchantSubscriptionListReq) SubscriptionSubscriptionListPostRequest {
	r.unibeeApiMerchantSubscriptionListReq = &unibeeApiMerchantSubscriptionListReq
	return r
}

func (r SubscriptionSubscriptionListPostRequest) Execute() (*MerchantSubscriptionListGet200Response, *http.Response, error) {
	return r.ApiService.SubscriptionListPostExecute(r)
}

/*
SubscriptionListPost Get Subscription List

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SubscriptionSubscriptionListPostRequest
*/
func (a *SubscriptionService) SubscriptionListPost(ctx context.Context) SubscriptionSubscriptionListPostRequest {
	return SubscriptionSubscriptionListPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MerchantSubscriptionListGet200Response
func (a *SubscriptionService) SubscriptionListPostExecute(r SubscriptionSubscriptionListPostRequest) (*MerchantSubscriptionListGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MerchantSubscriptionListGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubscriptionService.SubscriptionListPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/merchant/subscription/list"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.unibeeApiMerchantSubscriptionListReq == nil {
		return localVarReturnValue, nil, reportError("unibeeApiMerchantSubscriptionListReq is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.unibeeApiMerchantSubscriptionListReq
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SubscriptionSubscriptionPreviewSubscriptionNextInvoiceGetRequest struct {
	ctx context.Context
	ApiService *SubscriptionService
	subscriptionId *string
}

// SubscriptionId
func (r SubscriptionSubscriptionPreviewSubscriptionNextInvoiceGetRequest) SubscriptionId(subscriptionId string) SubscriptionSubscriptionPreviewSubscriptionNextInvoiceGetRequest {
	r.subscriptionId = &subscriptionId
	return r
}

func (r SubscriptionSubscriptionPreviewSubscriptionNextInvoiceGetRequest) Execute() (*MerchantSubscriptionPreviewSubscriptionNextInvoiceGet200Response, *http.Response, error) {
	return r.ApiService.SubscriptionPreviewSubscriptionNextInvoiceGetExecute(r)
}

/*
SubscriptionPreviewSubscriptionNextInvoiceGet Subscription Next Invoice Preview

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SubscriptionSubscriptionPreviewSubscriptionNextInvoiceGetRequest
*/
func (a *SubscriptionService) SubscriptionPreviewSubscriptionNextInvoiceGet(ctx context.Context) SubscriptionSubscriptionPreviewSubscriptionNextInvoiceGetRequest {
	return SubscriptionSubscriptionPreviewSubscriptionNextInvoiceGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MerchantSubscriptionPreviewSubscriptionNextInvoiceGet200Response
func (a *SubscriptionService) SubscriptionPreviewSubscriptionNextInvoiceGetExecute(r SubscriptionSubscriptionPreviewSubscriptionNextInvoiceGetRequest) (*MerchantSubscriptionPreviewSubscriptionNextInvoiceGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MerchantSubscriptionPreviewSubscriptionNextInvoiceGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubscriptionService.SubscriptionPreviewSubscriptionNextInvoiceGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/merchant/subscription/preview_subscription_next_invoice"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.subscriptionId == nil {
		return localVarReturnValue, nil, reportError("subscriptionId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "subscriptionId", r.subscriptionId, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SubscriptionSubscriptionUserPendingCryptoSubscriptionDetailGetRequest struct {
	ctx context.Context
	ApiService *SubscriptionService
	userId *int64
	externalUserId *string
	productId *int64
}

// UserId
func (r SubscriptionSubscriptionUserPendingCryptoSubscriptionDetailGetRequest) UserId(userId int64) SubscriptionSubscriptionUserPendingCryptoSubscriptionDetailGetRequest {
	r.userId = &userId
	return r
}

// ExternalUserId, unique, either ExternalUserId&amp;Email or UserId needed
func (r SubscriptionSubscriptionUserPendingCryptoSubscriptionDetailGetRequest) ExternalUserId(externalUserId string) SubscriptionSubscriptionUserPendingCryptoSubscriptionDetailGetRequest {
	r.externalUserId = &externalUserId
	return r
}

// default product will use if productId not specified and subscriptionId is blank
func (r SubscriptionSubscriptionUserPendingCryptoSubscriptionDetailGetRequest) ProductId(productId int64) SubscriptionSubscriptionUserPendingCryptoSubscriptionDetailGetRequest {
	r.productId = &productId
	return r
}

func (r SubscriptionSubscriptionUserPendingCryptoSubscriptionDetailGetRequest) Execute() (*MerchantSubscriptionUserPendingCryptoSubscriptionDetailGet200Response, *http.Response, error) {
	return r.ApiService.SubscriptionUserPendingCryptoSubscriptionDetailGetExecute(r)
}

/*
SubscriptionUserPendingCryptoSubscriptionDetailGet User Pending Crypto Subscription Detail

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SubscriptionSubscriptionUserPendingCryptoSubscriptionDetailGetRequest
*/
func (a *SubscriptionService) SubscriptionUserPendingCryptoSubscriptionDetailGet(ctx context.Context) SubscriptionSubscriptionUserPendingCryptoSubscriptionDetailGetRequest {
	return SubscriptionSubscriptionUserPendingCryptoSubscriptionDetailGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MerchantSubscriptionUserPendingCryptoSubscriptionDetailGet200Response
func (a *SubscriptionService) SubscriptionUserPendingCryptoSubscriptionDetailGetExecute(r SubscriptionSubscriptionUserPendingCryptoSubscriptionDetailGetRequest) (*MerchantSubscriptionUserPendingCryptoSubscriptionDetailGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MerchantSubscriptionUserPendingCryptoSubscriptionDetailGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubscriptionService.SubscriptionUserPendingCryptoSubscriptionDetailGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/merchant/subscription/user_pending_crypto_subscription_detail"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.userId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "userId", r.userId, "")
	}
	if r.externalUserId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "externalUserId", r.externalUserId, "")
	}
	if r.productId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "productId", r.productId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SubscriptionSubscriptionUserPendingCryptoSubscriptionDetailPostRequest struct {
	ctx context.Context
	ApiService *SubscriptionService
	unibeeApiMerchantSubscriptionUserPendingCryptoSubscriptionDetailReq *UnibeeApiMerchantSubscriptionUserPendingCryptoSubscriptionDetailReq
}

func (r SubscriptionSubscriptionUserPendingCryptoSubscriptionDetailPostRequest) UnibeeApiMerchantSubscriptionUserPendingCryptoSubscriptionDetailReq(unibeeApiMerchantSubscriptionUserPendingCryptoSubscriptionDetailReq UnibeeApiMerchantSubscriptionUserPendingCryptoSubscriptionDetailReq) SubscriptionSubscriptionUserPendingCryptoSubscriptionDetailPostRequest {
	r.unibeeApiMerchantSubscriptionUserPendingCryptoSubscriptionDetailReq = &unibeeApiMerchantSubscriptionUserPendingCryptoSubscriptionDetailReq
	return r
}

func (r SubscriptionSubscriptionUserPendingCryptoSubscriptionDetailPostRequest) Execute() (*MerchantSubscriptionUserPendingCryptoSubscriptionDetailGet200Response, *http.Response, error) {
	return r.ApiService.SubscriptionUserPendingCryptoSubscriptionDetailPostExecute(r)
}

/*
SubscriptionUserPendingCryptoSubscriptionDetailPost User Pending Crypto Subscription Detail

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SubscriptionSubscriptionUserPendingCryptoSubscriptionDetailPostRequest
*/
func (a *SubscriptionService) SubscriptionUserPendingCryptoSubscriptionDetailPost(ctx context.Context) SubscriptionSubscriptionUserPendingCryptoSubscriptionDetailPostRequest {
	return SubscriptionSubscriptionUserPendingCryptoSubscriptionDetailPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MerchantSubscriptionUserPendingCryptoSubscriptionDetailGet200Response
func (a *SubscriptionService) SubscriptionUserPendingCryptoSubscriptionDetailPostExecute(r SubscriptionSubscriptionUserPendingCryptoSubscriptionDetailPostRequest) (*MerchantSubscriptionUserPendingCryptoSubscriptionDetailGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MerchantSubscriptionUserPendingCryptoSubscriptionDetailGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubscriptionService.SubscriptionUserPendingCryptoSubscriptionDetailPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/merchant/subscription/user_pending_crypto_subscription_detail"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.unibeeApiMerchantSubscriptionUserPendingCryptoSubscriptionDetailReq == nil {
		return localVarReturnValue, nil, reportError("unibeeApiMerchantSubscriptionUserPendingCryptoSubscriptionDetailReq is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.unibeeApiMerchantSubscriptionUserPendingCryptoSubscriptionDetailReq
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SubscriptionSubscriptionUserSubscriptionDetailGetRequest struct {
	ctx context.Context
	ApiService *SubscriptionService
	userId *int64
	externalUserId *string
	productId *int64
}

// UserId
func (r SubscriptionSubscriptionUserSubscriptionDetailGetRequest) UserId(userId int64) SubscriptionSubscriptionUserSubscriptionDetailGetRequest {
	r.userId = &userId
	return r
}

// ExternalUserId, unique, either ExternalUserId&amp;Email or UserId needed
func (r SubscriptionSubscriptionUserSubscriptionDetailGetRequest) ExternalUserId(externalUserId string) SubscriptionSubscriptionUserSubscriptionDetailGetRequest {
	r.externalUserId = &externalUserId
	return r
}

// default product will use if productId not specified and subscriptionId is blank
func (r SubscriptionSubscriptionUserSubscriptionDetailGetRequest) ProductId(productId int64) SubscriptionSubscriptionUserSubscriptionDetailGetRequest {
	r.productId = &productId
	return r
}

func (r SubscriptionSubscriptionUserSubscriptionDetailGetRequest) Execute() (*MerchantSubscriptionUserSubscriptionDetailGet200Response, *http.Response, error) {
	return r.ApiService.SubscriptionUserSubscriptionDetailGetExecute(r)
}

/*
SubscriptionUserSubscriptionDetailGet User Subscription Detail

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SubscriptionSubscriptionUserSubscriptionDetailGetRequest
*/
func (a *SubscriptionService) SubscriptionUserSubscriptionDetailGet(ctx context.Context) SubscriptionSubscriptionUserSubscriptionDetailGetRequest {
	return SubscriptionSubscriptionUserSubscriptionDetailGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MerchantSubscriptionUserSubscriptionDetailGet200Response
func (a *SubscriptionService) SubscriptionUserSubscriptionDetailGetExecute(r SubscriptionSubscriptionUserSubscriptionDetailGetRequest) (*MerchantSubscriptionUserSubscriptionDetailGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MerchantSubscriptionUserSubscriptionDetailGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubscriptionService.SubscriptionUserSubscriptionDetailGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/merchant/subscription/user_subscription_detail"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.userId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "userId", r.userId, "")
	}
	if r.externalUserId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "externalUserId", r.externalUserId, "")
	}
	if r.productId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "productId", r.productId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type SubscriptionSubscriptionUserSubscriptionDetailPostRequest struct {
	ctx context.Context
	ApiService *SubscriptionService
	unibeeApiMerchantSubscriptionUserSubscriptionDetailReq *UnibeeApiMerchantSubscriptionUserSubscriptionDetailReq
}

func (r SubscriptionSubscriptionUserSubscriptionDetailPostRequest) UnibeeApiMerchantSubscriptionUserSubscriptionDetailReq(unibeeApiMerchantSubscriptionUserSubscriptionDetailReq UnibeeApiMerchantSubscriptionUserSubscriptionDetailReq) SubscriptionSubscriptionUserSubscriptionDetailPostRequest {
	r.unibeeApiMerchantSubscriptionUserSubscriptionDetailReq = &unibeeApiMerchantSubscriptionUserSubscriptionDetailReq
	return r
}

func (r SubscriptionSubscriptionUserSubscriptionDetailPostRequest) Execute() (*MerchantSubscriptionUserSubscriptionDetailGet200Response, *http.Response, error) {
	return r.ApiService.SubscriptionUserSubscriptionDetailPostExecute(r)
}

/*
SubscriptionUserSubscriptionDetailPost User Subscription Detail

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return SubscriptionSubscriptionUserSubscriptionDetailPostRequest
*/
func (a *SubscriptionService) SubscriptionUserSubscriptionDetailPost(ctx context.Context) SubscriptionSubscriptionUserSubscriptionDetailPostRequest {
	return SubscriptionSubscriptionUserSubscriptionDetailPostRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MerchantSubscriptionUserSubscriptionDetailGet200Response
func (a *SubscriptionService) SubscriptionUserSubscriptionDetailPostExecute(r SubscriptionSubscriptionUserSubscriptionDetailPostRequest) (*MerchantSubscriptionUserSubscriptionDetailGet200Response, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MerchantSubscriptionUserSubscriptionDetailGet200Response
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SubscriptionService.SubscriptionUserSubscriptionDetailPost")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/merchant/subscription/user_subscription_detail"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.unibeeApiMerchantSubscriptionUserSubscriptionDetailReq == nil {
		return localVarReturnValue, nil, reportError("unibeeApiMerchantSubscriptionUserSubscriptionDetailReq is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.unibeeApiMerchantSubscriptionUserSubscriptionDetailReq
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
